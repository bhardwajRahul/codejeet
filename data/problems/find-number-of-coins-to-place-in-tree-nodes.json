{
  "id": "2973",
  "title": "Find Number of Coins to Place in Tree Nodes",
  "slug": "find-number-of-coins-to-place-in-tree-nodes",
  "difficulty": "Hard",
  "category": "Algorithms",
  "content_html": "<p>You are given an <strong>undirected</strong> tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, and rooted at node <code>0</code>. You are given a 2D integer array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>\n\n<p>You are also given a <strong>0-indexed</strong> integer array <code>cost</code> of length <code>n</code>, where <code>cost[i]</code> is the <strong>cost</strong> assigned to the <code>i<sup>th</sup></code> node.</p>\n\n<p>You need to place some coins on every node of the tree. The number of coins to be placed at node <code>i</code> can be calculated as:</p>\n\n<ul>\n\t<li>If size of the subtree of node <code>i</code> is less than <code>3</code>, place <code>1</code> coin.</li>\n\t<li>Otherwise, place an amount of coins equal to the <strong>maximum</strong> product of cost values assigned to <code>3</code> distinct nodes in the subtree of node <code>i</code>. If this product is <strong>negative</strong>, place <code>0</code> coins.</li>\n</ul>\n\n<p>Return <em>an array </em><code>coin</code><em> of size </em><code>n</code><em> such that </em><code>coin[i]</code><em> is the number of coins placed at node </em><code>i</code><em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012641.png\" style=\"width: 600px; height: 233px;\" />\n<pre>\n<strong>Input:</strong> edges = [[0,1],[0,2],[0,3],[0,4],[0,5]], cost = [1,2,3,4,5,6]\n<strong>Output:</strong> [120,1,1,1,1,1]\n<strong>Explanation:</strong> For node 0 place 6 * 5 * 4 = 120 coins. All other nodes are leaves with subtree of size 1, place 1 coin on each of them.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012614.png\" style=\"width: 800px; height: 374px;\" />\n<pre>\n<strong>Input:</strong> edges = [[0,1],[0,2],[1,3],[1,4],[1,5],[2,6],[2,7],[2,8]], cost = [1,4,2,3,5,7,8,-4,2]\n<strong>Output:</strong> [280,140,32,1,1,1,1,1,1]\n<strong>Explanation:</strong> The coins placed on each node are:\n- Place 8 * 7 * 5 = 280 coins on node 0.\n- Place 7 * 5 * 4 = 140 coins on node 1.\n- Place 8 * 2 * 2 = 32 coins on node 2.\n- All other nodes are leaves with subtree of size 1, place 1 coin on each of them.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012513.png\" style=\"width: 300px; height: 277px;\" />\n<pre>\n<strong>Input:</strong> edges = [[0,1],[0,2]], cost = [1,2,-2]\n<strong>Output:</strong> [0,1,1]\n<strong>Explanation:</strong> Node 1 and 2 are leaves with subtree of size 1, place 1 coin on each of them. For node 0 the only possible product of cost is 2 * 1 * -2 = -4. Hence place 0 coins on node 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>cost.length == n</code></li>\n\t<li><code>1 &lt;= |cost[i]| &lt;= 10<sup>4</sup></code></li>\n\t<li>The input is generated such that <code>edges</code> represents a valid tree.</li>\n</ul>\n",
  "content_markdown": "You are given an **undirected** tree with `n` nodes labeled from `0` to `n - 1`, and rooted at node `0`. You are given a 2D integer array `edges` of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nYou are also given a **0-indexed** integer array `cost` of length `n`, where `cost[i]` is the **cost** assigned to the `ith` node.\n\nYou need to place some coins on every node of the tree. The number of coins to be placed at node `i` can be calculated as:\n\n  * If size of the subtree of node `i` is less than `3`, place `1` coin.\n  * Otherwise, place an amount of coins equal to the **maximum** product of cost values assigned to `3` distinct nodes in the subtree of node `i`. If this product is **negative** , place `0` coins.\n\n\n\nReturn _an array_`coin` _of size_`n` _such that_`coin[i]`_is the number of coins placed at node_`i` _._\n\n \n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012641.png)\n    \n    \n    **Input:** edges = [[0,1],[0,2],[0,3],[0,4],[0,5]], cost = [1,2,3,4,5,6]\n    **Output:** [120,1,1,1,1,1]\n    **Explanation:** For node 0 place 6 * 5 * 4 = 120 coins. All other nodes are leaves with subtree of size 1, place 1 coin on each of them.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012614.png)\n    \n    \n    **Input:** edges = [[0,1],[0,2],[1,3],[1,4],[1,5],[2,6],[2,7],[2,8]], cost = [1,4,2,3,5,7,8,-4,2]\n    **Output:** [280,140,32,1,1,1,1,1,1]\n    **Explanation:** The coins placed on each node are:\n    - Place 8 * 7 * 5 = 280 coins on node 0.\n    - Place 7 * 5 * 4 = 140 coins on node 1.\n    - Place 8 * 2 * 2 = 32 coins on node 2.\n    - All other nodes are leaves with subtree of size 1, place 1 coin on each of them.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012513.png)\n    \n    \n    **Input:** edges = [[0,1],[0,2]], cost = [1,2,-2]\n    **Output:** [0,1,1]\n    **Explanation:** Node 1 and 2 are leaves with subtree of size 1, place 1 coin on each of them. For node 0 the only possible product of cost is 2 * 1 * -2 = -4. Hence place 0 coins on node 0.\n    \n\n \n\n**Constraints:**\n\n  * `2 <= n <= 2 * 104`\n  * `edges.length == n - 1`\n  * `edges[i].length == 2`\n  * `0 <= ai, bi < n`\n  * `cost.length == n`\n  * `1 <= |cost[i]| <= 104`\n  * The input is generated such that `edges` represents a valid tree.",
  "question": "You are given an **undirected** tree with `n` nodes labeled from `0` to `n - 1`, and rooted at node `0`. You are given a 2D integer array `edges` of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nYou are also given a **0-indexed** integer array `cost` of length `n`, where `cost[i]` is the **cost** assigned to the `ith` node.\n\nYou need to place some coins on every node of the tree. The number of coins to be placed at node `i` can be calculated as:\n\n  * If size of the subtree of node `i` is less than `3`, place `1` coin.\n  * Otherwise, place an amount of coins equal to the **maximum** product of cost values assigned to `3` distinct nodes in the subtree of node `i`. If this product is **negative** , place `0` coins.\n\n\n\nReturn _an array_`coin` _of size_`n` _such that_`coin[i]`_is the number of coins placed at node_`i` _._",
  "examples": "**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012641.png)\n    \n    \n    **Input:** edges = [[0,1],[0,2],[0,3],[0,4],[0,5]], cost = [1,2,3,4,5,6]\n    **Output:** [120,1,1,1,1,1]\n    **Explanation:** For node 0 place 6 * 5 * 4 = 120 coins. All other nodes are leaves with subtree of size 1, place 1 coin on each of them.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012614.png)\n    \n    \n    **Input:** edges = [[0,1],[0,2],[1,3],[1,4],[1,5],[2,6],[2,7],[2,8]], cost = [1,4,2,3,5,7,8,-4,2]\n    **Output:** [280,140,32,1,1,1,1,1,1]\n    **Explanation:** The coins placed on each node are:\n    - Place 8 * 7 * 5 = 280 coins on node 0.\n    - Place 7 * 5 * 4 = 140 coins on node 1.\n    - Place 8 * 2 * 2 = 32 coins on node 2.\n    - All other nodes are leaves with subtree of size 1, place 1 coin on each of them.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012513.png)\n    \n    \n    **Input:** edges = [[0,1],[0,2]], cost = [1,2,-2]\n    **Output:** [0,1,1]\n    **Explanation:** Node 1 and 2 are leaves with subtree of size 1, place 1 coin on each of them. For node 0 the only possible product of cost is 2 * 1 * -2 = -4. Hence place 0 coins on node 0.",
  "constraints": "**Constraints:**\n\n  * `2 <= n <= 2 * 104`\n  * `edges.length == n - 1`\n  * `edges[i].length == 2`\n  * `0 <= ai, bi < n`\n  * `cost.length == n`\n  * `1 <= |cost[i]| <= 104`\n  * The input is generated such that `edges` represents a valid tree.",
  "topics": [
    "Dynamic Programming",
    "Tree",
    "Depth-First Search",
    "Sorting",
    "Heap (Priority Queue)"
  ],
  "total_accepted": 11148,
  "total_submissions": 29882,
  "acceptance_rate": "37.3%",
  "similar_questions": [
    {
      "title": "Collect Coins in a Tree",
      "slug": "collect-coins-in-a-tree",
      "difficulty": "Hard",
      "url": "https://leetcode.com/problems/collect-coins-in-a-tree/"
    },
    {
      "title": "Find the Maximum Sum of Node Values",
      "slug": "find-the-maximum-sum-of-node-values",
      "difficulty": "Hard",
      "url": "https://leetcode.com/problems/find-the-maximum-sum-of-node-values/"
    }
  ],
  "hints": [
    "Use DFS on the whole tree, for each subtree, save the largest three positive costs and the smallest three non-positive costs. This can be done by using two Heaps with the size of at most three.",
    "You need to store at most six values at each subtree.",
    "If there are more than three values in total, we can sort them. Let’s call the resultant array <code>A</code>, the maximum product of three is <code>max(A[0] * A[1] * A[n - 1], A[n - 1] * A[n - 2] * A[n - 3])</code>. Don’t forget to set the result to <code>0</code> if the value is negative.",
    "If there are less than three values for a subtree, set its result to <code>1</code>."
  ]
}
