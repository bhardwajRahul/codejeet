{
  "id": "2458",
  "title": "Height of Binary Tree After Subtree Removal Queries",
  "slug": "height-of-binary-tree-after-subtree-removal-queries",
  "difficulty": "Hard",
  "category": "Algorithms",
  "content_html": "<p>You are given the <code>root</code> of a <strong>binary tree</strong> with <code>n</code> nodes. Each node is assigned a unique value from <code>1</code> to <code>n</code>. You are also given an array <code>queries</code> of size <code>m</code>.</p>\n\n<p>You have to perform <code>m</code> <strong>independent</strong> queries on the tree where in the <code>i<sup>th</sup></code> query you do the following:</p>\n\n<ul>\n\t<li><strong>Remove</strong> the subtree rooted at the node with the value <code>queries[i]</code> from the tree. It is <strong>guaranteed</strong> that <code>queries[i]</code> will <strong>not</strong> be equal to the value of the root.</li>\n</ul>\n\n<p>Return <em>an array </em><code>answer</code><em> of size </em><code>m</code><em> where </em><code>answer[i]</code><em> is the height of the tree after performing the </em><code>i<sup>th</sup></code><em> query</em>.</p>\n\n<p><strong>Note</strong>:</p>\n\n<ul>\n\t<li>The queries are independent, so the tree returns to its <strong>initial</strong> state after each query.</li>\n\t<li>The height of a tree is the <strong>number of edges in the longest simple path</strong> from the root to some node in the tree.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-1.png\" style=\"width: 495px; height: 281px;\" />\n<pre>\n<strong>Input:</strong> root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]\n<strong>Output:</strong> [2]\n<strong>Explanation:</strong> The diagram above shows the tree after removing the subtree rooted at node with value 4.\nThe height of the tree is 2 (The path 1 -&gt; 3 -&gt; 2).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-2.png\" style=\"width: 301px; height: 284px;\" />\n<pre>\n<strong>Input:</strong> root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]\n<strong>Output:</strong> [3,2,3,2]\n<strong>Explanation:</strong> We have the following queries:\n- Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -&gt; 8 -&gt; 2 -&gt; 4).\n- Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -&gt; 8 -&gt; 1).\n- Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -&gt; 8 -&gt; 2 -&gt; 6).\n- Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -&gt; 9 -&gt; 3).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is <code>n</code>.</li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= n</code></li>\n\t<li>All the values in the tree are <strong>unique</strong>.</li>\n\t<li><code>m == queries.length</code></li>\n\t<li><code>1 &lt;= m &lt;= min(n, 10<sup>4</sup>)</code></li>\n\t<li><code>1 &lt;= queries[i] &lt;= n</code></li>\n\t<li><code>queries[i] != root.val</code></li>\n</ul>\n",
  "content_markdown": "You are given the `root` of a **binary tree** with `n` nodes. Each node is assigned a unique value from `1` to `n`. You are also given an array `queries` of size `m`.\n\nYou have to perform `m` **independent** queries on the tree where in the `ith` query you do the following:\n\n  * **Remove** the subtree rooted at the node with the value `queries[i]` from the tree. It is **guaranteed** that `queries[i]` will **not** be equal to the value of the root.\n\n\n\nReturn _an array_`answer` _of size_`m` _where_`answer[i]`_is the height of the tree after performing the_`ith` _query_.\n\n**Note** :\n\n  * The queries are independent, so the tree returns to its **initial** state after each query.\n  * The height of a tree is the **number of edges in the longest simple path** from the root to some node in the tree.\n\n\n\n \n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-1.png)\n    \n    \n    **Input:** root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]\n    **Output:** [2]\n    **Explanation:** The diagram above shows the tree after removing the subtree rooted at node with value 4.\n    The height of the tree is 2 (The path 1 -> 3 -> 2).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-2.png)\n    \n    \n    **Input:** root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]\n    **Output:** [3,2,3,2]\n    **Explanation:** We have the following queries:\n    - Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 4).\n    - Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -> 8 -> 1).\n    - Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 6).\n    - Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -> 9 -> 3).\n    \n\n \n\n**Constraints:**\n\n  * The number of nodes in the tree is `n`.\n  * `2 <= n <= 105`\n  * `1 <= Node.val <= n`\n  * All the values in the tree are **unique**.\n  * `m == queries.length`\n  * `1 <= m <= min(n, 104)`\n  * `1 <= queries[i] <= n`\n  * `queries[i] != root.val`",
  "question": "You are given the `root` of a **binary tree** with `n` nodes. Each node is assigned a unique value from `1` to `n`. You are also given an array `queries` of size `m`.\n\nYou have to perform `m` **independent** queries on the tree where in the `ith` query you do the following:\n\n  * **Remove** the subtree rooted at the node with the value `queries[i]` from the tree. It is **guaranteed** that `queries[i]` will **not** be equal to the value of the root.\n\n\n\nReturn _an array_`answer` _of size_`m` _where_`answer[i]`_is the height of the tree after performing the_`ith` _query_.\n\n**Note** :\n\n  * The queries are independent, so the tree returns to its **initial** state after each query.\n  * The height of a tree is the **number of edges in the longest simple path** from the root to some node in the tree.",
  "examples": "**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-1.png)\n    \n    \n    **Input:** root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]\n    **Output:** [2]\n    **Explanation:** The diagram above shows the tree after removing the subtree rooted at node with value 4.\n    The height of the tree is 2 (The path 1 -> 3 -> 2).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-2.png)\n    \n    \n    **Input:** root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]\n    **Output:** [3,2,3,2]\n    **Explanation:** We have the following queries:\n    - Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 4).\n    - Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -> 8 -> 1).\n    - Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 6).\n    - Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -> 9 -> 3).",
  "constraints": "**Constraints:**\n\n  * The number of nodes in the tree is `n`.\n  * `2 <= n <= 105`\n  * `1 <= Node.val <= n`\n  * All the values in the tree are **unique**.\n  * `m == queries.length`\n  * `1 <= m <= min(n, 104)`\n  * `1 <= queries[i] <= n`\n  * `queries[i] != root.val`",
  "topics": ["Array", "Tree", "Depth-First Search", "Breadth-First Search", "Binary Tree"],
  "total_accepted": 104313,
  "total_submissions": 190011,
  "acceptance_rate": "54.9%",
  "similar_questions": [
    {
      "title": "Maximum Depth of Binary Tree",
      "slug": "maximum-depth-of-binary-tree",
      "difficulty": "Easy",
      "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/"
    }
  ],
  "hints": [
    "Try pre-computing the answer for each node from 1 to n, and answer each query in O(1).",
    "The answers can be precomputed in a single tree traversal after computing the height of each subtree."
  ]
}
