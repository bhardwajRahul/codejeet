{
  "id": "2808",
  "title": "Minimum Seconds to Equalize a Circular Array",
  "slug": "minimum-seconds-to-equalize-a-circular-array",
  "difficulty": "Medium",
  "category": "Algorithms",
  "content_html": "<p>You are given a <strong>0-indexed</strong> array <code>nums</code> containing <code>n</code> integers.</p>\n\n<p>At each second, you perform the following operation on the array:</p>\n\n<ul>\n\t<li>For every index <code>i</code> in the range <code>[0, n - 1]</code>, replace <code>nums[i]</code> with either <code>nums[i]</code>, <code>nums[(i - 1 + n) % n]</code>, or <code>nums[(i + 1) % n]</code>.</li>\n</ul>\n\n<p><strong>Note</strong> that all the elements get replaced simultaneously.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of seconds needed to make all elements in the array</em> <code>nums</code> <em>equal</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We can equalize the array in 1 second in the following way:\n- At 1<sup>st</sup> second, replace values at each index with [nums[3],nums[1],nums[3],nums[3]]. After replacement, nums = [2,2,2,2].\nIt can be proven that 1 second is the minimum amount of seconds needed for equalizing the array.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,1,3,3,2]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can equalize the array in 2 seconds in the following way:\n- At 1<sup>st</sup> second, replace values at each index with [nums[0],nums[2],nums[2],nums[2],nums[3]]. After replacement, nums = [2,3,3,3,3].\n- At 2<sup>nd</sup> second, replace values at each index with [nums[1],nums[1],nums[2],nums[3],nums[4]]. After replacement, nums = [3,3,3,3,3].\nIt can be proven that 2 seconds is the minimum amount of seconds needed for equalizing the array.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,5,5,5]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> We don&#39;t need to perform any operations as all elements in the initial array are the same.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
  "content_markdown": "You are given a **0-indexed** array `nums` containing `n` integers.\n\nAt each second, you perform the following operation on the array:\n\n  * For every index `i` in the range `[0, n - 1]`, replace `nums[i]` with either `nums[i]`, `nums[(i - 1 + n) % n]`, or `nums[(i + 1) % n]`.\n\n\n\n**Note** that all the elements get replaced simultaneously.\n\nReturn _the**minimum** number of seconds needed to make all elements in the array_ `nums` _equal_.\n\n \n\n**Example 1:**\n    \n    \n    **Input:** nums = [1,2,1,2]\n    **Output:** 1\n    **Explanation:** We can equalize the array in 1 second in the following way:\n    - At 1st second, replace values at each index with [nums[3],nums[1],nums[3],nums[3]]. After replacement, nums = [2,2,2,2].\n    It can be proven that 1 second is the minimum amount of seconds needed for equalizing the array.\n    \n\n**Example 2:**\n    \n    \n    **Input:** nums = [2,1,3,3,2]\n    **Output:** 2\n    **Explanation:** We can equalize the array in 2 seconds in the following way:\n    - At 1st second, replace values at each index with [nums[0],nums[2],nums[2],nums[2],nums[3]]. After replacement, nums = [2,3,3,3,3].\n    - At 2nd second, replace values at each index with [nums[1],nums[1],nums[2],nums[3],nums[4]]. After replacement, nums = [3,3,3,3,3].\n    It can be proven that 2 seconds is the minimum amount of seconds needed for equalizing the array.\n    \n\n**Example 3:**\n    \n    \n    **Input:** nums = [5,5,5,5]\n    **Output:** 0\n    **Explanation:** We don't need to perform any operations as all elements in the initial array are the same.\n    \n\n \n\n**Constraints:**\n\n  * `1 <= n == nums.length <= 105`\n  * `1 <= nums[i] <= 109`",
  "question": "You are given a **0-indexed** array `nums` containing `n` integers.\n\nAt each second, you perform the following operation on the array:\n\n  * For every index `i` in the range `[0, n - 1]`, replace `nums[i]` with either `nums[i]`, `nums[(i - 1 + n) % n]`, or `nums[(i + 1) % n]`.\n\n\n\n**Note** that all the elements get replaced simultaneously.\n\nReturn _the**minimum** number of seconds needed to make all elements in the array_ `nums` _equal_.",
  "examples": "**Example 1:**\n    \n    \n    **Input:** nums = [1,2,1,2]\n    **Output:** 1\n    **Explanation:** We can equalize the array in 1 second in the following way:\n    - At 1st second, replace values at each index with [nums[3],nums[1],nums[3],nums[3]]. After replacement, nums = [2,2,2,2].\n    It can be proven that 1 second is the minimum amount of seconds needed for equalizing the array.\n    \n\n**Example 2:**\n    \n    \n    **Input:** nums = [2,1,3,3,2]\n    **Output:** 2\n    **Explanation:** We can equalize the array in 2 seconds in the following way:\n    - At 1st second, replace values at each index with [nums[0],nums[2],nums[2],nums[2],nums[3]]. After replacement, nums = [2,3,3,3,3].\n    - At 2nd second, replace values at each index with [nums[1],nums[1],nums[2],nums[3],nums[4]]. After replacement, nums = [3,3,3,3,3].\n    It can be proven that 2 seconds is the minimum amount of seconds needed for equalizing the array.\n    \n\n**Example 3:**\n    \n    \n    **Input:** nums = [5,5,5,5]\n    **Output:** 0\n    **Explanation:** We don't need to perform any operations as all elements in the initial array are the same.",
  "constraints": "**Constraints:**\n\n  * `1 <= n == nums.length <= 105`\n  * `1 <= nums[i] <= 109`",
  "topics": ["Array", "Hash Table"],
  "total_accepted": 18448,
  "total_submissions": 64824,
  "acceptance_rate": "28.5%",
  "similar_questions": [],
  "hints": [
    "For every possible x - the final value of the array, calculate the number of seconds needed to make all elements equal to x.",
    "Notice that if you take two consecutive occurrences (i, j) of x, then the number of operations to make segment [i + 1, j - 1] equal to x is floor((j - i) / 2)"
  ]
}
