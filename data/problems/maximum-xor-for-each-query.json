{
  "id": "1829",
  "title": "Maximum XOR for Each Query",
  "slug": "maximum-xor-for-each-query",
  "difficulty": "Medium",
  "category": "Algorithms",
  "content_html": "<p>You are given a <strong>sorted</strong> array <code>nums</code> of <code>n</code> non-negative integers and an integer <code>maximumBit</code>. You want to perform the following query <code>n</code> <strong>times</strong>:</p>\n\n<ol>\n\t<li>Find a non-negative integer <code>k &lt; 2<sup>maximumBit</sup></code> such that <code>nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k</code> is <strong>maximized</strong>. <code>k</code> is the answer to the <code>i<sup>th</sup></code> query.</li>\n\t<li>Remove the <strong>last </strong>element from the current array <code>nums</code>.</li>\n</ol>\n\n<p>Return <em>an array</em> <code>answer</code><em>, where </em><code>answer[i]</code><em> is the answer to the </em><code>i<sup>th</sup></code><em> query</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,1,3], maximumBit = 2\n<strong>Output:</strong> [0,3,2,3]\n<strong>Explanation</strong>: The queries are answered as follows:\n1<sup>st</sup> query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.\n2<sup>nd</sup> query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.\n3<sup>rd</sup> query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.\n4<sup>th</sup> query: nums = [0], k = 3 since 0 XOR 3 = 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,4,7], maximumBit = 3\n<strong>Output:</strong> [5,2,6,5]\n<strong>Explanation</strong>: The queries are answered as follows:\n1<sup>st</sup> query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.\n2<sup>nd</sup> query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.\n3<sup>rd</sup> query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.\n4<sup>th</sup> query: nums = [2], k = 5 since 2 XOR 5 = 7.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,2,2,5,7], maximumBit = 3\n<strong>Output:</strong> [4,3,6,4,6,7]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= maximumBit &lt;= 20</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; 2<sup>maximumBit</sup></code></li>\n\t<li><code>nums</code>​​​ is sorted in <strong>ascending</strong> order.</li>\n</ul>\n",
  "content_markdown": "You are given a **sorted** array `nums` of `n` non-negative integers and an integer `maximumBit`. You want to perform the following query `n` **times** :\n\n  1. Find a non-negative integer `k < 2maximumBit` such that `nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k` is **maximized**. `k` is the answer to the `ith` query.\n  2. Remove the **last** element from the current array `nums`.\n\n\n\nReturn _an array_ `answer` _, where_`answer[i]`_is the answer to the_`ith` _query_.\n\n \n\n**Example 1:**\n    \n    \n    **Input:** nums = [0,1,1,3], maximumBit = 2\n    **Output:** [0,3,2,3]\n    **Explanation** : The queries are answered as follows:\n    1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.\n    2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.\n    3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.\n    4th query: nums = [0], k = 3 since 0 XOR 3 = 3.\n    \n\n**Example 2:**\n    \n    \n    **Input:** nums = [2,3,4,7], maximumBit = 3\n    **Output:** [5,2,6,5]\n    **Explanation** : The queries are answered as follows:\n    1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.\n    2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.\n    3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.\n    4th query: nums = [2], k = 5 since 2 XOR 5 = 7.\n    \n\n**Example 3:**\n    \n    \n    **Input:** nums = [0,1,2,2,5,7], maximumBit = 3\n    **Output:** [4,3,6,4,6,7]\n    \n\n \n\n**Constraints:**\n\n  * `nums.length == n`\n  * `1 <= n <= 105`\n  * `1 <= maximumBit <= 20`\n  * `0 <= nums[i] < 2maximumBit`\n  * `nums`​​​ is sorted in **ascending** order.",
  "question": "You are given a **sorted** array `nums` of `n` non-negative integers and an integer `maximumBit`. You want to perform the following query `n` **times** :\n\n  1. Find a non-negative integer `k < 2maximumBit` such that `nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k` is **maximized**. `k` is the answer to the `ith` query.\n  2. Remove the **last** element from the current array `nums`.\n\n\n\nReturn _an array_ `answer` _, where_`answer[i]`_is the answer to the_`ith` _query_.",
  "examples": "**Example 1:**\n    \n    \n    **Input:** nums = [0,1,1,3], maximumBit = 2\n    **Output:** [0,3,2,3]\n    **Explanation** : The queries are answered as follows:\n    1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.\n    2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.\n    3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.\n    4th query: nums = [0], k = 3 since 0 XOR 3 = 3.\n    \n\n**Example 2:**\n    \n    \n    **Input:** nums = [2,3,4,7], maximumBit = 3\n    **Output:** [5,2,6,5]\n    **Explanation** : The queries are answered as follows:\n    1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.\n    2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.\n    3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.\n    4th query: nums = [2], k = 5 since 2 XOR 5 = 7.\n    \n\n**Example 3:**\n    \n    \n    **Input:** nums = [0,1,2,2,5,7], maximumBit = 3\n    **Output:** [4,3,6,4,6,7]",
  "constraints": "**Constraints:**\n\n  * `nums.length == n`\n  * `1 <= n <= 105`\n  * `1 <= maximumBit <= 20`\n  * `0 <= nums[i] < 2maximumBit`\n  * `nums`​​​ is sorted in **ascending** order.",
  "topics": ["Array", "Bit Manipulation", "Prefix Sum"],
  "total_accepted": 144237,
  "total_submissions": 170165,
  "acceptance_rate": "84.8%",
  "similar_questions": [
    {
      "title": "Count the Number of Beautiful Subarrays",
      "slug": "count-the-number-of-beautiful-subarrays",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/"
    }
  ],
  "hints": [
    "Note that the maximum possible XOR result is always 2^(maximumBit) - 1",
    "So the answer for a prefix is the XOR of that prefix XORed with 2^(maximumBit)-1"
  ]
}
