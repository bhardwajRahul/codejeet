{
  "id": "1111",
  "title": "Maximum Nesting Depth of Two Valid Parentheses Strings",
  "slug": "maximum-nesting-depth-of-two-valid-parentheses-strings",
  "difficulty": "Medium",
  "category": "Algorithms",
  "content_html": "<p>A string is a <em>valid parentheses string</em>&nbsp;(denoted VPS) if and only if it consists of <code>&quot;(&quot;</code> and <code>&quot;)&quot;</code> characters only, and:</p>\n\n<ul>\n\t<li>It is the empty string, or</li>\n\t<li>It can be written as&nbsp;<code>AB</code>&nbsp;(<code>A</code>&nbsp;concatenated with&nbsp;<code>B</code>), where&nbsp;<code>A</code>&nbsp;and&nbsp;<code>B</code>&nbsp;are VPS&#39;s, or</li>\n\t<li>It can be written as&nbsp;<code>(A)</code>, where&nbsp;<code>A</code>&nbsp;is a VPS.</li>\n</ul>\n\n<p>We can&nbsp;similarly define the <em>nesting depth</em> <code>depth(S)</code> of any VPS <code>S</code> as follows:</p>\n\n<ul>\n\t<li><code>depth(&quot;&quot;) = 0</code></li>\n\t<li><code>depth(A + B) = max(depth(A), depth(B))</code>, where <code>A</code> and <code>B</code> are VPS&#39;s</li>\n\t<li><code>depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>, where <code>A</code> is a VPS.</li>\n</ul>\n\n<p>For example, <code>&quot;&quot;</code>,&nbsp;<code>&quot;()()&quot;</code>, and&nbsp;<code>&quot;()(()())&quot;</code>&nbsp;are VPS&#39;s (with nesting depths 0, 1, and 2), and <code>&quot;)(&quot;</code> and <code>&quot;(()&quot;</code> are not VPS&#39;s.</p>\n\n<p>Given a VPS <font face=\"monospace\">seq</font>, split it into two disjoint subsequences <code>A</code> and <code>B</code>, such that&nbsp;<code>A</code> and <code>B</code> are VPS&#39;s (and&nbsp;<code>A.length + B.length = seq.length</code>). The subsequences may not necessarily be contiguous.</p>\n\n<p>For example, for the sequence <code>123456789</code>, one possible split is:</p>\n\n<ul data-end=\"822\" data-start=\"776\">\n\t<li data-end=\"800\" data-start=\"776\">\n\t<p data-end=\"800\" data-start=\"778\"><code data-end=\"799\" data-start=\"778\">A = {1, 3, 5, 7, 9}</code>,</p>\n\t</li>\n\t<li data-end=\"822\" data-start=\"801\">\n\t<p data-end=\"822\" data-start=\"803\"><code data-end=\"821\" data-start=\"803\">B = {2, 4, 6, 8}</code>.</p>\n\t</li>\n</ul>\n\n<p data-end=\"855\" data-start=\"824\">This corresponds to the output <code>[0, 1, 0, 1, 0, 1, 0, 1, 0]</code> &nbsp;where 0 indicates membership in&nbsp;<code data-end=\"929\" data-start=\"926\">A</code>&nbsp;and 1 indicates membership in&nbsp;<code data-end=\"965\" data-start=\"962\">B</code>.</p>\n\n<p>Now choose <strong>any</strong> such <code>A</code> and <code>B</code> such that&nbsp;<code>max(depth(A), depth(B))</code> is the minimum possible value.</p>\n\n<p>Return an <code>answer</code> array (of length <code>seq.length</code>) that encodes such a&nbsp;choice of <code>A</code> and <code>B</code>:&nbsp; <code>answer[i] = 0</code> if <code>seq[i]</code> is part of <code>A</code>, else <code>answer[i] = 1</code>.&nbsp; Note that even though multiple answers may exist, you may return any of them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> seq = &quot;(()())&quot;\n<strong>Output:</strong> [0,1,1,1,1,0]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> seq = &quot;()(())()&quot;\n<strong>Output:</strong> [0,0,0,1,1,0,1,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= seq.size &lt;= 10000</code></li>\n</ul>\n",
  "content_markdown": "A string is a _valid parentheses string_  (denoted VPS) if and only if it consists of `\"(\"` and `\")\"` characters only, and:\n\n  * It is the empty string, or\n  * It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are VPS's, or\n  * It can be written as `(A)`, where `A` is a VPS.\n\n\n\nWe can similarly define the _nesting depth_ `depth(S)` of any VPS `S` as follows:\n\n  * `depth(\"\") = 0`\n  * `depth(A + B) = max(depth(A), depth(B))`, where `A` and `B` are VPS's\n  * `depth(\"(\" + A + \")\") = 1 + depth(A)`, where `A` is a VPS.\n\n\n\nFor example, `\"\"`, `\"()()\"`, and `\"()(()())\"` are VPS's (with nesting depths 0, 1, and 2), and `\")(\"` and `\"(()\"` are not VPS's.\n\nGiven a VPS seq, split it into two disjoint subsequences `A` and `B`, such that `A` and `B` are VPS's (and `A.length + B.length = seq.length`). The subsequences may not necessarily be contiguous.\n\nFor example, for the sequence `123456789`, one possible split is:\n\n  * `A = {1, 3, 5, 7, 9}`,\n\n  * `B = {2, 4, 6, 8}`.\n\n\n\n\nThis corresponds to the output `[0, 1, 0, 1, 0, 1, 0, 1, 0]`  where 0 indicates membership in `A` and 1 indicates membership in `B`.\n\nNow choose **any** such `A` and `B` such that `max(depth(A), depth(B))` is the minimum possible value.\n\nReturn an `answer` array (of length `seq.length`) that encodes such a choice of `A` and `B`:  `answer[i] = 0` if `seq[i]` is part of `A`, else `answer[i] = 1`.  Note that even though multiple answers may exist, you may return any of them.\n\n \n\n**Example 1:**\n    \n    \n    **Input:** seq = \"(()())\"\n    **Output:** [0,1,1,1,1,0]\n    \n\n**Example 2:**\n    \n    \n    **Input:** seq = \"()(())()\"\n    **Output:** [0,0,0,1,1,0,1,1]\n    \n\n \n\n**Constraints:**\n\n  * `1 <= seq.size <= 10000`",
  "question": "A string is a _valid parentheses string_  (denoted VPS) if and only if it consists of `\"(\"` and `\")\"` characters only, and:\n\n  * It is the empty string, or\n  * It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are VPS's, or\n  * It can be written as `(A)`, where `A` is a VPS.\n\n\n\nWe can similarly define the _nesting depth_ `depth(S)` of any VPS `S` as follows:\n\n  * `depth(\"\") = 0`\n  * `depth(A + B) = max(depth(A), depth(B))`, where `A` and `B` are VPS's\n  * `depth(\"(\" + A + \")\") = 1 + depth(A)`, where `A` is a VPS.\n\n\n\nFor example, `\"\"`, `\"()()\"`, and `\"()(()())\"` are VPS's (with nesting depths 0, 1, and 2), and `\")(\"` and `\"(()\"` are not VPS's.\n\nGiven a VPS seq, split it into two disjoint subsequences `A` and `B`, such that `A` and `B` are VPS's (and `A.length + B.length = seq.length`). The subsequences may not necessarily be contiguous.\n\nFor example, for the sequence `123456789`, one possible split is:\n\n  * `A = {1, 3, 5, 7, 9}`,\n\n  * `B = {2, 4, 6, 8}`.\n\n\n\n\nThis corresponds to the output `[0, 1, 0, 1, 0, 1, 0, 1, 0]`  where 0 indicates membership in `A` and 1 indicates membership in `B`.\n\nNow choose **any** such `A` and `B` such that `max(depth(A), depth(B))` is the minimum possible value.\n\nReturn an `answer` array (of length `seq.length`) that encodes such a choice of `A` and `B`:  `answer[i] = 0` if `seq[i]` is part of `A`, else `answer[i] = 1`.  Note that even though multiple answers may exist, you may return any of them.",
  "examples": "**Example 1:**\n    \n    \n    **Input:** seq = \"(()())\"\n    **Output:** [0,1,1,1,1,0]\n    \n\n**Example 2:**\n    \n    \n    **Input:** seq = \"()(())()\"\n    **Output:** [0,0,0,1,1,0,1,1]",
  "constraints": "**Constraints:**\n\n  * `1 <= seq.size <= 10000`",
  "topics": ["String", "Stack"],
  "total_accepted": 32983,
  "total_submissions": 45909,
  "acceptance_rate": "71.8%",
  "similar_questions": [
    {
      "title": "Maximum Nesting Depth of the Parentheses",
      "slug": "maximum-nesting-depth-of-the-parentheses",
      "difficulty": "Easy",
      "url": "https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/"
    }
  ],
  "hints": []
}
