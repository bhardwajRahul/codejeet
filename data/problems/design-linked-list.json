{
  "id": "707",
  "title": "Design Linked List",
  "slug": "design-linked-list",
  "difficulty": "Medium",
  "category": "Algorithms",
  "content_html": "<p>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.<br />\nA node in a singly linked list should have two attributes: <code>val</code> and <code>next</code>. <code>val</code> is the value of the current node, and <code>next</code> is a pointer/reference to the next node.<br />\nIf you want to use the doubly linked list, you will need one more attribute <code>prev</code> to indicate the previous node in the linked list. Assume all nodes in the linked list are <strong>0-indexed</strong>.</p>\n\n<p>Implement the <code>MyLinkedList</code> class:</p>\n\n<ul>\n\t<li><code>MyLinkedList()</code> Initializes the <code>MyLinkedList</code> object.</li>\n\t<li><code>int get(int index)</code> Get the value of the <code>index<sup>th</sup></code> node in the linked list. If the index is invalid, return <code>-1</code>.</li>\n\t<li><code>void addAtHead(int val)</code> Add a node of value <code>val</code> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li>\n\t<li><code>void addAtTail(int val)</code> Append a node of value <code>val</code> as the last element of the linked list.</li>\n\t<li><code>void addAtIndex(int index, int val)</code> Add a node of value <code>val</code> before the <code>index<sup>th</sup></code> node in the linked list. If <code>index</code> equals the length of the linked list, the node will be appended to the end of the linked list. If <code>index</code> is greater than the length, the node <strong>will not be inserted</strong>.</li>\n\t<li><code>void deleteAtIndex(int index)</code> Delete the <code>index<sup>th</sup></code> node in the linked list, if the index is valid.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]\n[[], [1], [3], [1, 2], [1], [1], [1]]\n<strong>Output</strong>\n[null, null, null, null, 2, null, 3]\n\n<strong>Explanation</strong>\nMyLinkedList myLinkedList = new MyLinkedList();\nmyLinkedList.addAtHead(1);\nmyLinkedList.addAtTail(3);\nmyLinkedList.addAtIndex(1, 2);    // linked list becomes 1-&gt;2-&gt;3\nmyLinkedList.get(1);              // return 2\nmyLinkedList.deleteAtIndex(1);    // now the linked list is 1-&gt;3\nmyLinkedList.get(1);              // return 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= index, val &lt;= 1000</code></li>\n\t<li>Please do not use the built-in LinkedList library.</li>\n\t<li>At most <code>2000</code> calls will be made to <code>get</code>, <code>addAtHead</code>, <code>addAtTail</code>, <code>addAtIndex</code> and <code>deleteAtIndex</code>.</li>\n</ul>\n",
  "content_markdown": "Design your implementation of the linked list. You can choose to use a singly or doubly linked list.  \nA node in a singly linked list should have two attributes: `val` and `next`. `val` is the value of the current node, and `next` is a pointer/reference to the next node.  \nIf you want to use the doubly linked list, you will need one more attribute `prev` to indicate the previous node in the linked list. Assume all nodes in the linked list are **0-indexed**.\n\nImplement the `MyLinkedList` class:\n\n  * `MyLinkedList()` Initializes the `MyLinkedList` object.\n  * `int get(int index)` Get the value of the `indexth` node in the linked list. If the index is invalid, return `-1`.\n  * `void addAtHead(int val)` Add a node of value `val` before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n  * `void addAtTail(int val)` Append a node of value `val` as the last element of the linked list.\n  * `void addAtIndex(int index, int val)` Add a node of value `val` before the `indexth` node in the linked list. If `index` equals the length of the linked list, the node will be appended to the end of the linked list. If `index` is greater than the length, the node **will not be inserted**.\n  * `void deleteAtIndex(int index)` Delete the `indexth` node in the linked list, if the index is valid.\n\n\n\n \n\n**Example 1:**\n    \n    \n    **Input**\n    [\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n    [[], [1], [3], [1, 2], [1], [1], [1]]\n    **Output**\n    [null, null, null, null, 2, null, 3]\n    \n    **Explanation**\n    MyLinkedList myLinkedList = new MyLinkedList();\n    myLinkedList.addAtHead(1);\n    myLinkedList.addAtTail(3);\n    myLinkedList.addAtIndex(1, 2);    // linked list becomes 1->2->3\n    myLinkedList.get(1);              // return 2\n    myLinkedList.deleteAtIndex(1);    // now the linked list is 1->3\n    myLinkedList.get(1);              // return 3\n    \n\n \n\n**Constraints:**\n\n  * `0 <= index, val <= 1000`\n  * Please do not use the built-in LinkedList library.\n  * At most `2000` calls will be made to `get`, `addAtHead`, `addAtTail`, `addAtIndex` and `deleteAtIndex`.",
  "question": "Design your implementation of the linked list. You can choose to use a singly or doubly linked list.  \nA node in a singly linked list should have two attributes: `val` and `next`. `val` is the value of the current node, and `next` is a pointer/reference to the next node.  \nIf you want to use the doubly linked list, you will need one more attribute `prev` to indicate the previous node in the linked list. Assume all nodes in the linked list are **0-indexed**.\n\nImplement the `MyLinkedList` class:\n\n  * `MyLinkedList()` Initializes the `MyLinkedList` object.\n  * `int get(int index)` Get the value of the `indexth` node in the linked list. If the index is invalid, return `-1`.\n  * `void addAtHead(int val)` Add a node of value `val` before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n  * `void addAtTail(int val)` Append a node of value `val` as the last element of the linked list.\n  * `void addAtIndex(int index, int val)` Add a node of value `val` before the `indexth` node in the linked list. If `index` equals the length of the linked list, the node will be appended to the end of the linked list. If `index` is greater than the length, the node **will not be inserted**.\n  * `void deleteAtIndex(int index)` Delete the `indexth` node in the linked list, if the index is valid.",
  "examples": "**Example 1:**\n    \n    \n    **Input**\n    [\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n    [[], [1], [3], [1, 2], [1], [1], [1]]\n    **Output**\n    [null, null, null, null, 2, null, 3]\n    \n    **Explanation**\n    MyLinkedList myLinkedList = new MyLinkedList();\n    myLinkedList.addAtHead(1);\n    myLinkedList.addAtTail(3);\n    myLinkedList.addAtIndex(1, 2);    // linked list becomes 1->2->3\n    myLinkedList.get(1);              // return 2\n    myLinkedList.deleteAtIndex(1);    // now the linked list is 1->3\n    myLinkedList.get(1);              // return 3",
  "constraints": "**Constraints:**\n\n  * `0 <= index, val <= 1000`\n  * Please do not use the built-in LinkedList library.\n  * At most `2000` calls will be made to `get`, `addAtHead`, `addAtTail`, `addAtIndex` and `deleteAtIndex`.",
  "topics": ["Linked List", "Design"],
  "total_accepted": 475918,
  "total_submissions": 1591291,
  "acceptance_rate": "29.9%",
  "similar_questions": [
    {
      "title": "Design Skiplist",
      "slug": "design-skiplist",
      "difficulty": "Hard",
      "url": "https://leetcode.com/problems/design-skiplist/"
    }
  ],
  "hints": []
}
