{
  "id": "2642",
  "title": "Design Graph With Shortest Path Calculator",
  "slug": "design-graph-with-shortest-path-calculator",
  "difficulty": "Hard",
  "category": "Algorithms",
  "content_html": "<p>There is a <strong>directed weighted</strong> graph that consists of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>. The edges of the graph are initially represented by the given array <code>edges</code> where <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, edgeCost<sub>i</sub>]</code> meaning that there is an edge from <code>from<sub>i</sub></code> to <code>to<sub>i</sub></code> with the cost <code>edgeCost<sub>i</sub></code>.</p>\n\n<p>Implement the <code>Graph</code> class:</p>\n\n<ul>\n\t<li><code>Graph(int n, int[][] edges)</code> initializes the object with <code>n</code> nodes and the given edges.</li>\n\t<li><code>addEdge(int[] edge)</code> adds an edge to the list of edges where <code>edge = [from, to, edgeCost]</code>. It is guaranteed that there is no edge between the two nodes before adding this one.</li>\n\t<li><code>int shortestPath(int node1, int node2)</code> returns the <strong>minimum</strong> cost of a path from <code>node1</code> to <code>node2</code>. If no path exists, return <code>-1</code>. The cost of a path is the sum of the costs of the edges in the path.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png\" style=\"width: 621px; height: 191px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;Graph&quot;, &quot;shortestPath&quot;, &quot;shortestPath&quot;, &quot;addEdge&quot;, &quot;shortestPath&quot;]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\n<strong>Output</strong>\n[null, 6, -1, null, 6]\n\n<strong>Explanation</strong>\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -&gt; 0 -&gt; 1 -&gt; 2 with a total cost of 3 + 2 + 1 = 6.\ng.shortestPath(0, 3); // return -1. There is no path from 0 to 3.\ng.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.\ng.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -&gt; 1 -&gt; 3 with a total cost of 2 + 4 = 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= edges.length &lt;= n * (n - 1)</code></li>\n\t<li><code>edges[i].length == edge.length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, from, to, node1, node2 &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= edgeCost<sub>i</sub>, edgeCost &lt;= 10<sup>6</sup></code></li>\n\t<li>There are no repeated edges and no self-loops in the graph at any point.</li>\n\t<li>At most <code>100</code> calls will be made for <code>addEdge</code>.</li>\n\t<li>At most <code>100</code> calls will be made for <code>shortestPath</code>.</li>\n</ul>\n",
  "content_markdown": "There is a **directed weighted** graph that consists of `n` nodes numbered from `0` to `n - 1`. The edges of the graph are initially represented by the given array `edges` where `edges[i] = [fromi, toi, edgeCosti]` meaning that there is an edge from `fromi` to `toi` with the cost `edgeCosti`.\n\nImplement the `Graph` class:\n\n  * `Graph(int n, int[][] edges)` initializes the object with `n` nodes and the given edges.\n  * `addEdge(int[] edge)` adds an edge to the list of edges where `edge = [from, to, edgeCost]`. It is guaranteed that there is no edge between the two nodes before adding this one.\n  * `int shortestPath(int node1, int node2)` returns the **minimum** cost of a path from `node1` to `node2`. If no path exists, return `-1`. The cost of a path is the sum of the costs of the edges in the path.\n\n\n\n \n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png)\n    \n    \n    **Input**\n    [\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n    [[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\n    **Output**\n    [null, 6, -1, null, 6]\n    \n    **Explanation**\n    Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\n    g.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.\n    g.shortestPath(0, 3); // return -1. There is no path from 0 to 3.\n    g.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.\n    g.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.\n    \n\n \n\n**Constraints:**\n\n  * `1 <= n <= 100`\n  * `0 <= edges.length <= n * (n - 1)`\n  * `edges[i].length == edge.length == 3`\n  * `0 <= fromi, toi, from, to, node1, node2 <= n - 1`\n  * `1 <= edgeCosti, edgeCost <= 106`\n  * There are no repeated edges and no self-loops in the graph at any point.\n  * At most `100` calls will be made for `addEdge`.\n  * At most `100` calls will be made for `shortestPath`.",
  "question": "There is a **directed weighted** graph that consists of `n` nodes numbered from `0` to `n - 1`. The edges of the graph are initially represented by the given array `edges` where `edges[i] = [fromi, toi, edgeCosti]` meaning that there is an edge from `fromi` to `toi` with the cost `edgeCosti`.\n\nImplement the `Graph` class:\n\n  * `Graph(int n, int[][] edges)` initializes the object with `n` nodes and the given edges.\n  * `addEdge(int[] edge)` adds an edge to the list of edges where `edge = [from, to, edgeCost]`. It is guaranteed that there is no edge between the two nodes before adding this one.\n  * `int shortestPath(int node1, int node2)` returns the **minimum** cost of a path from `node1` to `node2`. If no path exists, return `-1`. The cost of a path is the sum of the costs of the edges in the path.",
  "examples": "**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png)\n    \n    \n    **Input**\n    [\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n    [[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\n    **Output**\n    [null, 6, -1, null, 6]\n    \n    **Explanation**\n    Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\n    g.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.\n    g.shortestPath(0, 3); // return -1. There is no path from 0 to 3.\n    g.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.\n    g.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.",
  "constraints": "**Constraints:**\n\n  * `1 <= n <= 100`\n  * `0 <= edges.length <= n * (n - 1)`\n  * `edges[i].length == edge.length == 3`\n  * `0 <= fromi, toi, from, to, node1, node2 <= n - 1`\n  * `1 <= edgeCosti, edgeCost <= 106`\n  * There are no repeated edges and no self-loops in the graph at any point.\n  * At most `100` calls will be made for `addEdge`.\n  * At most `100` calls will be made for `shortestPath`.",
  "topics": ["Graph Theory", "Design", "Heap (Priority Queue)", "Shortest Path"],
  "total_accepted": 78327,
  "total_submissions": 120728,
  "acceptance_rate": "64.9%",
  "similar_questions": [
    {
      "title": "Number of Restricted Paths From First to Last Node",
      "slug": "number-of-restricted-paths-from-first-to-last-node",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/"
    },
    {
      "title": "Closest Node to Path in Tree",
      "slug": "closest-node-to-path-in-tree",
      "difficulty": "Hard",
      "url": "https://leetcode.com/problems/closest-node-to-path-in-tree/"
    }
  ],
  "hints": [
    "After adding each edge, update your graph with the new edge, and you can calculate the shortest path in your graph each time the shortestPath method is called.",
    "Use dijkstra’s algorithm to calculate the shortest paths."
  ]
}
