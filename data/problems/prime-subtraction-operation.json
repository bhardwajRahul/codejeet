{
  "id": "2601",
  "title": "Prime Subtraction Operation",
  "slug": "prime-subtraction-operation",
  "difficulty": "Medium",
  "category": "Algorithms",
  "content_html": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code>.</p>\n\n<p>You can perform the following operation as many times as you want:</p>\n\n<ul>\n\t<li>Pick an index <code>i</code> that you haven&rsquo;t picked before, and pick a prime <code>p</code> <strong>strictly less than</strong> <code>nums[i]</code>, then subtract <code>p</code> from <code>nums[i]</code>.</li>\n</ul>\n\n<p>Return <em>true if you can make <code>nums</code> a strictly increasing array using the above operation and false otherwise.</em></p>\n\n<p>A <strong>strictly increasing array</strong> is an array whose each element is strictly greater than its preceding element.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,9,6,10]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> In the first operation: Pick i = 0 and p = 3, and then subtract 3 from nums[0], so that nums becomes [1,9,6,10].\nIn the second operation: i = 1, p = 7, subtract 7 from nums[1], so nums becomes equal to [1,2,6,10].\nAfter the second operation, nums is sorted in strictly increasing order, so the answer is true.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [6,8,11,12]\n<strong>Output:</strong> true\n<strong>Explanation: </strong>Initially nums is sorted in strictly increasing order, so we don&#39;t need to make any operations.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,8,3]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> It can be proven that there is no way to perform operations to make nums sorted in strictly increasing order, so the answer is false.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code><font face=\"monospace\">nums.length == n</font></code></li>\n</ul>\n",
  "content_markdown": "You are given a **0-indexed** integer array `nums` of length `n`.\n\nYou can perform the following operation as many times as you want:\n\n  * Pick an index `i` that you haven’t picked before, and pick a prime `p` **strictly less than** `nums[i]`, then subtract `p` from `nums[i]`.\n\n\n\nReturn _true if you can make`nums` a strictly increasing array using the above operation and false otherwise._\n\nA **strictly increasing array** is an array whose each element is strictly greater than its preceding element.\n\n \n\n**Example 1:**\n    \n    \n    **Input:** nums = [4,9,6,10]\n    **Output:** true\n    **Explanation:** In the first operation: Pick i = 0 and p = 3, and then subtract 3 from nums[0], so that nums becomes [1,9,6,10].\n    In the second operation: i = 1, p = 7, subtract 7 from nums[1], so nums becomes equal to [1,2,6,10].\n    After the second operation, nums is sorted in strictly increasing order, so the answer is true.\n\n**Example 2:**\n    \n    \n    **Input:** nums = [6,8,11,12]\n    **Output:** true\n    **Explanation:** Initially nums is sorted in strictly increasing order, so we don't need to make any operations.\n\n**Example 3:**\n    \n    \n    **Input:** nums = [5,8,3]\n    **Output:** false\n    **Explanation:** It can be proven that there is no way to perform operations to make nums sorted in strictly increasing order, so the answer is false.\n\n \n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `1 <= nums[i] <= 1000`\n  * `nums.length == n`",
  "question": "You are given a **0-indexed** integer array `nums` of length `n`.\n\nYou can perform the following operation as many times as you want:\n\n  * Pick an index `i` that you haven’t picked before, and pick a prime `p` **strictly less than** `nums[i]`, then subtract `p` from `nums[i]`.\n\n\n\nReturn _true if you can make`nums` a strictly increasing array using the above operation and false otherwise._\n\nA **strictly increasing array** is an array whose each element is strictly greater than its preceding element.",
  "examples": "**Example 1:**\n    \n    \n    **Input:** nums = [4,9,6,10]\n    **Output:** true\n    **Explanation:** In the first operation: Pick i = 0 and p = 3, and then subtract 3 from nums[0], so that nums becomes [1,9,6,10].\n    In the second operation: i = 1, p = 7, subtract 7 from nums[1], so nums becomes equal to [1,2,6,10].\n    After the second operation, nums is sorted in strictly increasing order, so the answer is true.\n\n**Example 2:**\n    \n    \n    **Input:** nums = [6,8,11,12]\n    **Output:** true\n    **Explanation:** Initially nums is sorted in strictly increasing order, so we don't need to make any operations.\n\n**Example 3:**\n    \n    \n    **Input:** nums = [5,8,3]\n    **Output:** false\n    **Explanation:** It can be proven that there is no way to perform operations to make nums sorted in strictly increasing order, so the answer is false.",
  "constraints": "**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `1 <= nums[i] <= 1000`\n  * `nums.length == n`",
  "topics": ["Array", "Math", "Binary Search", "Greedy", "Number Theory"],
  "total_accepted": 119477,
  "total_submissions": 214975,
  "acceptance_rate": "55.6%",
  "similar_questions": [],
  "hints": [
    "Think about if we have many primes to subtract from nums[i]. Which prime is more optimal?",
    "The most optimal prime to subtract from nums[i] is the one that makes nums[i] the smallest as possible and greater than nums[i-1]."
  ]
}
