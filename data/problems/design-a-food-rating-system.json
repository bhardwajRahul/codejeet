{
  "id": "2353",
  "title": "Design a Food Rating System",
  "slug": "design-a-food-rating-system",
  "difficulty": "Medium",
  "category": "Algorithms",
  "content_html": "<p>Design a food rating system that can do the following:</p>\n\n<ul>\n\t<li><strong>Modify</strong> the rating of a food item listed in the system.</li>\n\t<li>Return the highest-rated food item for a type of cuisine in the system.</li>\n</ul>\n\n<p>Implement the <code>FoodRatings</code> class:</p>\n\n<ul>\n\t<li><code>FoodRatings(String[] foods, String[] cuisines, int[] ratings)</code> Initializes the system. The food items are described by <code>foods</code>, <code>cuisines</code> and <code>ratings</code>, all of which have a length of <code>n</code>.\n\n\t<ul>\n\t\t<li><code>foods[i]</code> is the name of the <code>i<sup>th</sup></code> food,</li>\n\t\t<li><code>cuisines[i]</code> is the type of cuisine of the <code>i<sup>th</sup></code> food, and</li>\n\t\t<li><code>ratings[i]</code> is the initial rating of the <code>i<sup>th</sup></code> food.</li>\n\t</ul>\n\t</li>\n\t<li><code>void changeRating(String food, int newRating)</code> Changes the rating of the food item with the name <code>food</code>.</li>\n\t<li><code>String highestRated(String cuisine)</code> Returns the name of the food item that has the highest rating for the given type of <code>cuisine</code>. If there is a tie, return the item with the <strong>lexicographically smaller</strong> name.</li>\n</ul>\n\n<p>Note that a string <code>x</code> is lexicographically smaller than string <code>y</code> if <code>x</code> comes before <code>y</code> in dictionary order, that is, either <code>x</code> is a prefix of <code>y</code>, or if <code>i</code> is the first position such that <code>x[i] != y[i]</code>, then <code>x[i]</code> comes before <code>y[i]</code> in alphabetic order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;FoodRatings&quot;, &quot;highestRated&quot;, &quot;highestRated&quot;, &quot;changeRating&quot;, &quot;highestRated&quot;, &quot;changeRating&quot;, &quot;highestRated&quot;]\n[[[&quot;kimchi&quot;, &quot;miso&quot;, &quot;sushi&quot;, &quot;moussaka&quot;, &quot;ramen&quot;, &quot;bulgogi&quot;], [&quot;korean&quot;, &quot;japanese&quot;, &quot;japanese&quot;, &quot;greek&quot;, &quot;japanese&quot;, &quot;korean&quot;], [9, 12, 8, 15, 14, 7]], [&quot;korean&quot;], [&quot;japanese&quot;], [&quot;sushi&quot;, 16], [&quot;japanese&quot;], [&quot;ramen&quot;, 16], [&quot;japanese&quot;]]\n<strong>Output</strong>\n[null, &quot;kimchi&quot;, &quot;ramen&quot;, null, &quot;sushi&quot;, null, &quot;ramen&quot;]\n\n<strong>Explanation</strong>\nFoodRatings foodRatings = new FoodRatings([&quot;kimchi&quot;, &quot;miso&quot;, &quot;sushi&quot;, &quot;moussaka&quot;, &quot;ramen&quot;, &quot;bulgogi&quot;], [&quot;korean&quot;, &quot;japanese&quot;, &quot;japanese&quot;, &quot;greek&quot;, &quot;japanese&quot;, &quot;korean&quot;], [9, 12, 8, 15, 14, 7]);\nfoodRatings.highestRated(&quot;korean&quot;); // return &quot;kimchi&quot;\n                                    // &quot;kimchi&quot; is the highest rated korean food with a rating of 9.\nfoodRatings.highestRated(&quot;japanese&quot;); // return &quot;ramen&quot;\n                                      // &quot;ramen&quot; is the highest rated japanese food with a rating of 14.\nfoodRatings.changeRating(&quot;sushi&quot;, 16); // &quot;sushi&quot; now has a rating of 16.\nfoodRatings.highestRated(&quot;japanese&quot;); // return &quot;sushi&quot;\n                                      // &quot;sushi&quot; is the highest rated japanese food with a rating of 16.\nfoodRatings.changeRating(&quot;ramen&quot;, 16); // &quot;ramen&quot; now has a rating of 16.\nfoodRatings.highestRated(&quot;japanese&quot;); // return &quot;ramen&quot;\n                                      // Both &quot;sushi&quot; and &quot;ramen&quot; have a rating of 16.\n                                      // However, &quot;ramen&quot; is lexicographically smaller than &quot;sushi&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>n == foods.length == cuisines.length == ratings.length</code></li>\n\t<li><code>1 &lt;= foods[i].length, cuisines[i].length &lt;= 10</code></li>\n\t<li><code>foods[i]</code>, <code>cuisines[i]</code> consist of lowercase English letters.</li>\n\t<li><code>1 &lt;= ratings[i] &lt;= 10<sup>8</sup></code></li>\n\t<li>All the strings in <code>foods</code> are <strong>distinct</strong>.</li>\n\t<li><code>food</code> will be the name of a food item in the system across all calls to <code>changeRating</code>.</li>\n\t<li><code>cuisine</code> will be a type of cuisine of <strong>at least one</strong> food item in the system across all calls to <code>highestRated</code>.</li>\n\t<li>At most <code>2 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>changeRating</code> and <code>highestRated</code>.</li>\n</ul>\n",
  "content_markdown": "Design a food rating system that can do the following:\n\n  * **Modify** the rating of a food item listed in the system.\n  * Return the highest-rated food item for a type of cuisine in the system.\n\n\n\nImplement the `FoodRatings` class:\n\n  * `FoodRatings(String[] foods, String[] cuisines, int[] ratings)` Initializes the system. The food items are described by `foods`, `cuisines` and `ratings`, all of which have a length of `n`. \n    * `foods[i]` is the name of the `ith` food,\n    * `cuisines[i]` is the type of cuisine of the `ith` food, and\n    * `ratings[i]` is the initial rating of the `ith` food.\n  * `void changeRating(String food, int newRating)` Changes the rating of the food item with the name `food`.\n  * `String highestRated(String cuisine)` Returns the name of the food item that has the highest rating for the given type of `cuisine`. If there is a tie, return the item with the **lexicographically smaller** name.\n\n\n\nNote that a string `x` is lexicographically smaller than string `y` if `x` comes before `y` in dictionary order, that is, either `x` is a prefix of `y`, or if `i` is the first position such that `x[i] != y[i]`, then `x[i]` comes before `y[i]` in alphabetic order.\n\n \n\n**Example 1:**\n    \n    \n    **Input**\n    [\"FoodRatings\", \"highestRated\", \"highestRated\", \"changeRating\", \"highestRated\", \"changeRating\", \"highestRated\"]\n    [[[\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]], [\"korean\"], [\"japanese\"], [\"sushi\", 16], [\"japanese\"], [\"ramen\", 16], [\"japanese\"]]\n    **Output**\n    [null, \"kimchi\", \"ramen\", null, \"sushi\", null, \"ramen\"]\n    \n    **Explanation**\n    FoodRatings foodRatings = new FoodRatings([\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]);\n    foodRatings.highestRated(\"korean\"); // return \"kimchi\"\n                                        // \"kimchi\" is the highest rated korean food with a rating of 9.\n    foodRatings.highestRated(\"japanese\"); // return \"ramen\"\n                                          // \"ramen\" is the highest rated japanese food with a rating of 14.\n    foodRatings.changeRating(\"sushi\", 16); // \"sushi\" now has a rating of 16.\n    foodRatings.highestRated(\"japanese\"); // return \"sushi\"\n                                          // \"sushi\" is the highest rated japanese food with a rating of 16.\n    foodRatings.changeRating(\"ramen\", 16); // \"ramen\" now has a rating of 16.\n    foodRatings.highestRated(\"japanese\"); // return \"ramen\"\n                                          // Both \"sushi\" and \"ramen\" have a rating of 16.\n                                          // However, \"ramen\" is lexicographically smaller than \"sushi\".\n    \n\n \n\n**Constraints:**\n\n  * `1 <= n <= 2 * 104`\n  * `n == foods.length == cuisines.length == ratings.length`\n  * `1 <= foods[i].length, cuisines[i].length <= 10`\n  * `foods[i]`, `cuisines[i]` consist of lowercase English letters.\n  * `1 <= ratings[i] <= 108`\n  * All the strings in `foods` are **distinct**.\n  * `food` will be the name of a food item in the system across all calls to `changeRating`.\n  * `cuisine` will be a type of cuisine of **at least one** food item in the system across all calls to `highestRated`.\n  * At most `2 * 104` calls **in total** will be made to `changeRating` and `highestRated`.",
  "question": "Design a food rating system that can do the following:\n\n  * **Modify** the rating of a food item listed in the system.\n  * Return the highest-rated food item for a type of cuisine in the system.\n\n\n\nImplement the `FoodRatings` class:\n\n  * `FoodRatings(String[] foods, String[] cuisines, int[] ratings)` Initializes the system. The food items are described by `foods`, `cuisines` and `ratings`, all of which have a length of `n`. \n    * `foods[i]` is the name of the `ith` food,\n    * `cuisines[i]` is the type of cuisine of the `ith` food, and\n    * `ratings[i]` is the initial rating of the `ith` food.\n  * `void changeRating(String food, int newRating)` Changes the rating of the food item with the name `food`.\n  * `String highestRated(String cuisine)` Returns the name of the food item that has the highest rating for the given type of `cuisine`. If there is a tie, return the item with the **lexicographically smaller** name.\n\n\n\nNote that a string `x` is lexicographically smaller than string `y` if `x` comes before `y` in dictionary order, that is, either `x` is a prefix of `y`, or if `i` is the first position such that `x[i] != y[i]`, then `x[i]` comes before `y[i]` in alphabetic order.",
  "examples": "**Example 1:**\n    \n    \n    **Input**\n    [\"FoodRatings\", \"highestRated\", \"highestRated\", \"changeRating\", \"highestRated\", \"changeRating\", \"highestRated\"]\n    [[[\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]], [\"korean\"], [\"japanese\"], [\"sushi\", 16], [\"japanese\"], [\"ramen\", 16], [\"japanese\"]]\n    **Output**\n    [null, \"kimchi\", \"ramen\", null, \"sushi\", null, \"ramen\"]\n    \n    **Explanation**\n    FoodRatings foodRatings = new FoodRatings([\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]);\n    foodRatings.highestRated(\"korean\"); // return \"kimchi\"\n                                        // \"kimchi\" is the highest rated korean food with a rating of 9.\n    foodRatings.highestRated(\"japanese\"); // return \"ramen\"\n                                          // \"ramen\" is the highest rated japanese food with a rating of 14.\n    foodRatings.changeRating(\"sushi\", 16); // \"sushi\" now has a rating of 16.\n    foodRatings.highestRated(\"japanese\"); // return \"sushi\"\n                                          // \"sushi\" is the highest rated japanese food with a rating of 16.\n    foodRatings.changeRating(\"ramen\", 16); // \"ramen\" now has a rating of 16.\n    foodRatings.highestRated(\"japanese\"); // return \"ramen\"\n                                          // Both \"sushi\" and \"ramen\" have a rating of 16.\n                                          // However, \"ramen\" is lexicographically smaller than \"sushi\".",
  "constraints": "**Constraints:**\n\n  * `1 <= n <= 2 * 104`\n  * `n == foods.length == cuisines.length == ratings.length`\n  * `1 <= foods[i].length, cuisines[i].length <= 10`\n  * `foods[i]`, `cuisines[i]` consist of lowercase English letters.\n  * `1 <= ratings[i] <= 108`\n  * All the strings in `foods` are **distinct**.\n  * `food` will be the name of a food item in the system across all calls to `changeRating`.\n  * `cuisine` will be a type of cuisine of **at least one** food item in the system across all calls to `highestRated`.\n  * At most `2 * 104` calls **in total** will be made to `changeRating` and `highestRated`.",
  "topics": ["Array", "Hash Table", "String", "Design", "Heap (Priority Queue)", "Ordered Set"],
  "total_accepted": 180956,
  "total_submissions": 342249,
  "acceptance_rate": "52.9%",
  "similar_questions": [
    {
      "title": "Design a Number Container System",
      "slug": "design-a-number-container-system",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/design-a-number-container-system/"
    },
    {
      "title": "Most Popular Video Creator",
      "slug": "most-popular-video-creator",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/most-popular-video-creator/"
    }
  ],
  "hints": [
    "The key to solving this problem is to properly store the data using the right data structures.",
    "Firstly, a hash table is needed to efficiently map each food item to its cuisine and current rating.",
    "In addition, another hash table is needed to map cuisines to foods within each cuisine stored in an ordered set according to their ratings."
  ]
}
