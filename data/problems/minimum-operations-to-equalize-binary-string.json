{
  "id": "3666",
  "title": "Minimum Operations to Equalize Binary String",
  "slug": "minimum-operations-to-equalize-binary-string",
  "difficulty": "Hard",
  "category": "Algorithms",
  "content_html": "<p>You are given a binary string <code>s</code>, and an integer <code>k</code>.</p>\n\n<p>In one operation, you must choose <strong>exactly</strong> <code>k</code> <strong>different</strong> indices and <strong>flip</strong> each <code>&#39;0&#39;</code> to <code>&#39;1&#39;</code> and each <code>&#39;1&#39;</code> to <code>&#39;0&#39;</code>.</p>\n\n<p>Return the <strong>minimum</strong> number of operations required to make all characters in the string equal to <code>&#39;1&#39;</code>. If it is not possible, return -1.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;110&quot;, k = 1</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">1</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li>There is one <code>&#39;0&#39;</code> in <code>s</code>.</li>\n\t<li>Since <code>k = 1</code>, we can flip it directly in one operation.</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;0101&quot;, k = 3</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>One optimal set of operations choosing <code>k = 3</code> indices in each operation is:</p>\n\n<ul>\n\t<li><strong>Operation 1</strong>: Flip indices <code>[0, 1, 3]</code>. <code>s</code> changes from <code>&quot;0101&quot;</code> to <code>&quot;1000&quot;</code>.</li>\n\t<li><strong>Operation 2</strong>: Flip indices <code>[1, 2, 3]</code>. <code>s</code> changes from <code>&quot;1000&quot;</code> to <code>&quot;1111&quot;</code>.</li>\n</ul>\n\n<p>Thus, the minimum number of operations is 2.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;101&quot;, k = 2</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">-1</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Since <code>k = 2</code> and <code>s</code> has only one <code>&#39;0&#39;</code>, it is impossible to flip exactly <code>k</code> indices to make all <code>&#39;1&#39;</code>. Hence, the answer is -1.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>​​​​​​​5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n\t<li><code>1 &lt;= k &lt;= s.length</code></li>\n</ul>\n",
  "content_markdown": "You are given a binary string `s`, and an integer `k`.\n\nIn one operation, you must choose **exactly** `k` **different** indices and **flip** each `'0'` to `'1'` and each `'1'` to `'0'`.\n\nReturn the **minimum** number of operations required to make all characters in the string equal to `'1'`. If it is not possible, return -1.\n\n \n\n**Example 1:**\n\n**Input:** s = \"110\", k = 1\n\n**Output:** 1\n\n**Explanation:**\n\n  * There is one `'0'` in `s`.\n  * Since `k = 1`, we can flip it directly in one operation.\n\n\n\n**Example 2:**\n\n**Input:** s = \"0101\", k = 3\n\n**Output:** 2\n\n**Explanation:**\n\nOne optimal set of operations choosing `k = 3` indices in each operation is:\n\n  * **Operation 1** : Flip indices `[0, 1, 3]`. `s` changes from `\"0101\"` to `\"1000\"`.\n  * **Operation 2** : Flip indices `[1, 2, 3]`. `s` changes from `\"1000\"` to `\"1111\"`.\n\n\n\nThus, the minimum number of operations is 2.\n\n**Example 3:**\n\n**Input:** s = \"101\", k = 2\n\n**Output:** -1\n\n**Explanation:**\n\nSince `k = 2` and `s` has only one `'0'`, it is impossible to flip exactly `k` indices to make all `'1'`. Hence, the answer is -1.\n\n \n\n**Constraints:**\n\n  * `1 <= s.length <= 10​​​​​​​5`\n  * `s[i]` is either `'0'` or `'1'`.\n  * `1 <= k <= s.length`",
  "question": "You are given a binary string `s`, and an integer `k`.\n\nIn one operation, you must choose **exactly** `k` **different** indices and **flip** each `'0'` to `'1'` and each `'1'` to `'0'`.\n\nReturn the **minimum** number of operations required to make all characters in the string equal to `'1'`. If it is not possible, return -1.",
  "examples": "**Example 1:**\n\n**Input:** s = \"110\", k = 1\n\n**Output:** 1\n\n**Explanation:**\n\n  * There is one `'0'` in `s`.\n  * Since `k = 1`, we can flip it directly in one operation.\n\n\n\n**Example 2:**\n\n**Input:** s = \"0101\", k = 3\n\n**Output:** 2\n\n**Explanation:**\n\nOne optimal set of operations choosing `k = 3` indices in each operation is:\n\n  * **Operation 1** : Flip indices `[0, 1, 3]`. `s` changes from `\"0101\"` to `\"1000\"`.\n  * **Operation 2** : Flip indices `[1, 2, 3]`. `s` changes from `\"1000\"` to `\"1111\"`.\n\n\n\nThus, the minimum number of operations is 2.\n\n**Example 3:**\n\n**Input:** s = \"101\", k = 2\n\n**Output:** -1\n\n**Explanation:**\n\nSince `k = 2` and `s` has only one `'0'`, it is impossible to flip exactly `k` indices to make all `'1'`. Hence, the answer is -1.",
  "constraints": "**Constraints:**\n\n  * `1 <= s.length <= 10​​​​​​​5`\n  * `s[i]` is either `'0'` or `'1'`.\n  * `1 <= k <= s.length`",
  "topics": ["Math", "String", "Breadth-First Search", "Union-Find", "Ordered Set"],
  "total_accepted": 58376,
  "total_submissions": 127899,
  "acceptance_rate": "45.6%",
  "similar_questions": [],
  "hints": [
    "Model state as <code>z</code> = number of zeros; flipping <code>k</code> picks <code>i</code> zeros (<code>i</code> between <code>max(0, k - (n - z))</code> and <code>min(k, z)</code>) and transforms <code>z</code> to <code>z'</code> = <code>z + k - 2 * i</code>, so <code>z'</code> lies in a contiguous range and has parity <code>(z + k) % 2</code>.",
    "Build a graph on states <code>0..n</code> and run <code>BFS</code> from initial <code>z</code> to reach <code>0</code>; each edge from <code>z</code> goes to all <code>z'</code> in that computed interval.",
    "For speed, keep two ordered sets of unvisited states by parity and erase ranges with <code>lower_bound</code> while <code>BFSing</code> to achieve near <code>O(n log n)</code> time."
  ]
}
