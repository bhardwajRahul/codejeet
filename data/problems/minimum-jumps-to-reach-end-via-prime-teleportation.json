{
  "id": "3629",
  "title": "Minimum Jumps to Reach End via Prime Teleportation",
  "slug": "minimum-jumps-to-reach-end-via-prime-teleportation",
  "difficulty": "Medium",
  "category": "Algorithms",
  "content_html": "<p>You are given an integer array <code>nums</code> of length <code>n</code>.</p>\n\n<p>You start at index 0, and your goal is to reach index <code>n - 1</code>.</p>\n\n<p>From any index <code>i</code>, you may perform one of the following operations:</p>\n\n<ul>\n\t<li><strong>Adjacent Step</strong>: Jump to index <code>i + 1</code> or <code>i - 1</code>, if the index is within bounds.</li>\n\t<li><strong>Prime Teleportation</strong>: If <code>nums[i]</code> is a <span data-keyword=\"prime-number\">prime number</span> <code>p</code>, you may instantly jump to any index <code>j != i</code> such that <code>nums[j] % p == 0</code>.</li>\n</ul>\n\n<p>Return the <strong>minimum</strong> number of jumps required to reach index <code>n - 1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [1,2,4,6]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>One optimal sequence of jumps is:</p>\n\n<ul>\n\t<li>Start at index <code>i = 0</code>. Take an adjacent step to index 1.</li>\n\t<li>At index <code>i = 1</code>, <code>nums[1] = 2</code> is a prime number. Therefore, we teleport to index <code>i = 3</code> as <code>nums[3] = 6</code> is divisible by 2.</li>\n</ul>\n\n<p>Thus, the answer is 2.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [2,3,4,7,9]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>One optimal sequence of jumps is:</p>\n\n<ul>\n\t<li>Start at index <code>i = 0</code>. Take an adjacent step to index <code>i = 1</code>.</li>\n\t<li>At index <code>i = 1</code>, <code>nums[1] = 3</code> is a prime number. Therefore, we teleport to index <code>i = 4</code> since <code>nums[4] = 9</code> is divisible by 3.</li>\n</ul>\n\n<p>Thus, the answer is 2.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [4,6,5,8]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">3</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li>Since no teleportation is possible, we move through <code>0 &rarr; 1 &rarr; 2 &rarr; 3</code>. Thus, the answer is 3.</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
  "content_markdown": "You are given an integer array `nums` of length `n`.\n\nYou start at index 0, and your goal is to reach index `n - 1`.\n\nFrom any index `i`, you may perform one of the following operations:\n\n  * **Adjacent Step** : Jump to index `i + 1` or `i - 1`, if the index is within bounds.\n  * **Prime Teleportation** : If `nums[i]` is a prime number `p`, you may instantly jump to any index `j != i` such that `nums[j] % p == 0`.\n\n\n\nReturn the **minimum** number of jumps required to reach index `n - 1`.\n\n \n\n**Example 1:**\n\n**Input:** nums = [1,2,4,6]\n\n**Output:** 2\n\n**Explanation:**\n\nOne optimal sequence of jumps is:\n\n  * Start at index `i = 0`. Take an adjacent step to index 1.\n  * At index `i = 1`, `nums[1] = 2` is a prime number. Therefore, we teleport to index `i = 3` as `nums[3] = 6` is divisible by 2.\n\n\n\nThus, the answer is 2.\n\n**Example 2:**\n\n**Input:** nums = [2,3,4,7,9]\n\n**Output:** 2\n\n**Explanation:**\n\nOne optimal sequence of jumps is:\n\n  * Start at index `i = 0`. Take an adjacent step to index `i = 1`.\n  * At index `i = 1`, `nums[1] = 3` is a prime number. Therefore, we teleport to index `i = 4` since `nums[4] = 9` is divisible by 3.\n\n\n\nThus, the answer is 2.\n\n**Example 3:**\n\n**Input:** nums = [4,6,5,8]\n\n**Output:** 3\n\n**Explanation:**\n\n  * Since no teleportation is possible, we move through `0 → 1 → 2 → 3`. Thus, the answer is 3.\n\n\n\n \n\n**Constraints:**\n\n  * `1 <= n == nums.length <= 105`\n  * `1 <= nums[i] <= 106`",
  "question": "You are given an integer array `nums` of length `n`.\n\nYou start at index 0, and your goal is to reach index `n - 1`.\n\nFrom any index `i`, you may perform one of the following operations:\n\n  * **Adjacent Step** : Jump to index `i + 1` or `i - 1`, if the index is within bounds.\n  * **Prime Teleportation** : If `nums[i]` is a prime number `p`, you may instantly jump to any index `j != i` such that `nums[j] % p == 0`.\n\n\n\nReturn the **minimum** number of jumps required to reach index `n - 1`.",
  "examples": "**Example 1:**\n\n**Input:** nums = [1,2,4,6]\n\n**Output:** 2\n\n**Explanation:**\n\nOne optimal sequence of jumps is:\n\n  * Start at index `i = 0`. Take an adjacent step to index 1.\n  * At index `i = 1`, `nums[1] = 2` is a prime number. Therefore, we teleport to index `i = 3` as `nums[3] = 6` is divisible by 2.\n\n\n\nThus, the answer is 2.\n\n**Example 2:**\n\n**Input:** nums = [2,3,4,7,9]\n\n**Output:** 2\n\n**Explanation:**\n\nOne optimal sequence of jumps is:\n\n  * Start at index `i = 0`. Take an adjacent step to index `i = 1`.\n  * At index `i = 1`, `nums[1] = 3` is a prime number. Therefore, we teleport to index `i = 4` since `nums[4] = 9` is divisible by 3.\n\n\n\nThus, the answer is 2.\n\n**Example 3:**\n\n**Input:** nums = [4,6,5,8]\n\n**Output:** 3\n\n**Explanation:**\n\n  * Since no teleportation is possible, we move through `0 → 1 → 2 → 3`. Thus, the answer is 3.",
  "constraints": "**Constraints:**\n\n  * `1 <= n == nums.length <= 105`\n  * `1 <= nums[i] <= 106`",
  "topics": ["Array", "Hash Table", "Math", "Breadth-First Search", "Number Theory"],
  "total_accepted": 26062,
  "total_submissions": 81892,
  "acceptance_rate": "31.8%",
  "similar_questions": [],
  "hints": [
    "Use a breadth-first search.",
    "Precompute prime factors of each <code>nums[i]</code> via a sieve, and build a bucket <code>bucket[p]</code> mapping each prime <code>p</code> to all indices <code>j</code> with <code>nums[j] % p == 0</code>.",
    "During the BFS, when at index <code>i</code>, enqueue its adjacent steps (<code>i+1</code> and <code>i-1</code>) and all indices in <code>bucket[p]</code> for each prime <code>p</code> dividing <code>nums[i]</code>, then clear <code>bucket[p]</code> so each prime's bucket is visited only once."
  ]
}
