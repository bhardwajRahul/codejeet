{
  "id": "3690",
  "title": "Split and Merge Array Transformation",
  "slug": "split-and-merge-array-transformation",
  "difficulty": "Medium",
  "category": "Algorithms",
  "content_html": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, each of length <code>n</code>. You may perform the following <strong>split-and-merge operation</strong> on <code>nums1</code> any number of times:</p>\n\n<ol>\n\t<li>Choose a subarray <code>nums1[L..R]</code>.</li>\n\t<li>Remove that subarray, leaving the prefix <code>nums1[0..L-1]</code> (empty if <code>L = 0</code>) and the suffix <code>nums1[R+1..n-1]</code> (empty if <code>R = n - 1</code>).</li>\n\t<li>Re-insert the removed subarray (in its original order) at <strong>any</strong> position in the remaining array (i.e., between any two elements, at the very start, or at the very end).</li>\n</ol>\n\n<p>Return the <strong>minimum</strong> number of <strong>split-and-merge operations</strong> needed to transform <code>nums1</code> into <code>nums2</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums1 = [3,1,2], nums2 = [1,2,3]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">1</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li>Split out the subarray <code>[3]</code> (<code>L = 0</code>, <code>R = 0</code>); the remaining array is <code>[1,2]</code>.</li>\n\t<li>Insert <code>[3]</code> at the end; the array becomes <code>[1,2,3]</code>.</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums1 = </span>[1,1,2,3,4,5]<span class=\"example-io\">, nums2 = </span>[5,4,3,2,1,1]</p>\n\n<p><strong>Output: </strong>3</p>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li>Remove <code>[1,1,2]</code> at indices <code>0 - 2</code>; remaining is <code>[3,4,5]</code>; insert <code>[1,1,2]</code> at position <code>2</code>, resulting in <code>[3,4,1,1,2,5]</code>.</li>\n\t<li>Remove <code>[4,1,1]</code> at indices <code>1 - 3</code>; remaining is <code>[3,2,5]</code>; insert <code>[4,1,1]</code> at position <code>3</code>, resulting in <code>[3,2,5,4,1,1]</code>.</li>\n\t<li>Remove <code>[3,2]</code> at indices <code>0 - 1</code>; remaining is <code>[5,4,1,1]</code>; insert <code>[3,2]</code> at position <code>2</code>, resulting in <code>[5,4,3,2,1,1]</code>.</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n == nums1.length == nums2.length &lt;= 6</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums2</code> is a <strong>permutation</strong> of <code>nums1</code>.</li>\n</ul>\n",
  "content_markdown": "You are given two integer arrays `nums1` and `nums2`, each of length `n`. You may perform the following **split-and-merge operation** on `nums1` any number of times:\n\n  1. Choose a subarray `nums1[L..R]`.\n  2. Remove that subarray, leaving the prefix `nums1[0..L-1]` (empty if `L = 0`) and the suffix `nums1[R+1..n-1]` (empty if `R = n - 1`).\n  3. Re-insert the removed subarray (in its original order) at **any** position in the remaining array (i.e., between any two elements, at the very start, or at the very end).\n\n\n\nReturn the **minimum** number of **split-and-merge operations** needed to transform `nums1` into `nums2`.\n\n \n\n**Example 1:**\n\n**Input:** nums1 = [3,1,2], nums2 = [1,2,3]\n\n**Output:** 1\n\n**Explanation:**\n\n  * Split out the subarray `[3]` (`L = 0`, `R = 0`); the remaining array is `[1,2]`.\n  * Insert `[3]` at the end; the array becomes `[1,2,3]`.\n\n\n\n**Example 2:**\n\n**Input:** nums1 = [1,1,2,3,4,5], nums2 = [5,4,3,2,1,1]\n\n**Output:** 3\n\n**Explanation:**\n\n  * Remove `[1,1,2]` at indices `0 - 2`; remaining is `[3,4,5]`; insert `[1,1,2]` at position `2`, resulting in `[3,4,1,1,2,5]`.\n  * Remove `[4,1,1]` at indices `1 - 3`; remaining is `[3,2,5]`; insert `[4,1,1]` at position `3`, resulting in `[3,2,5,4,1,1]`.\n  * Remove `[3,2]` at indices `0 - 1`; remaining is `[5,4,1,1]`; insert `[3,2]` at position `2`, resulting in `[5,4,3,2,1,1]`.\n\n\n\n \n\n**Constraints:**\n\n  * `2 <= n == nums1.length == nums2.length <= 6`\n  * `-105 <= nums1[i], nums2[i] <= 105`\n  * `nums2` is a **permutation** of `nums1`.",
  "question": "You are given two integer arrays `nums1` and `nums2`, each of length `n`. You may perform the following **split-and-merge operation** on `nums1` any number of times:\n\n  1. Choose a subarray `nums1[L..R]`.\n  2. Remove that subarray, leaving the prefix `nums1[0..L-1]` (empty if `L = 0`) and the suffix `nums1[R+1..n-1]` (empty if `R = n - 1`).\n  3. Re-insert the removed subarray (in its original order) at **any** position in the remaining array (i.e., between any two elements, at the very start, or at the very end).\n\n\n\nReturn the **minimum** number of **split-and-merge operations** needed to transform `nums1` into `nums2`.",
  "examples": "**Example 1:**\n\n**Input:** nums1 = [3,1,2], nums2 = [1,2,3]\n\n**Output:** 1\n\n**Explanation:**\n\n  * Split out the subarray `[3]` (`L = 0`, `R = 0`); the remaining array is `[1,2]`.\n  * Insert `[3]` at the end; the array becomes `[1,2,3]`.\n\n\n\n**Example 2:**\n\n**Input:** nums1 = [1,1,2,3,4,5], nums2 = [5,4,3,2,1,1]\n\n**Output:** 3\n\n**Explanation:**\n\n  * Remove `[1,1,2]` at indices `0 - 2`; remaining is `[3,4,5]`; insert `[1,1,2]` at position `2`, resulting in `[3,4,1,1,2,5]`.\n  * Remove `[4,1,1]` at indices `1 - 3`; remaining is `[3,2,5]`; insert `[4,1,1]` at position `3`, resulting in `[3,2,5,4,1,1]`.\n  * Remove `[3,2]` at indices `0 - 1`; remaining is `[5,4,1,1]`; insert `[3,2]` at position `2`, resulting in `[5,4,3,2,1,1]`.",
  "constraints": "**Constraints:**\n\n  * `2 <= n == nums1.length == nums2.length <= 6`\n  * `-105 <= nums1[i], nums2[i] <= 105`\n  * `nums2` is a **permutation** of `nums1`.",
  "topics": ["Array", "Hash Table", "Breadth-First Search"],
  "total_accepted": 24764,
  "total_submissions": 42270,
  "acceptance_rate": "58.6%",
  "similar_questions": [],
  "hints": [
    "Use <code>BFS</code> over the space of array states, starting from <code>nums1</code> and aiming for <code>nums2</code>.",
    "Represent each state as an array (or tuple) and enqueue it alongside its current operation count.",
    "Maintain a visited set (e.g. a hash set or dictionary keyed by the state) to avoid revisiting the same configuration.",
    "For each dequeued state, generate all possible \"split-and-merge\" successors by choosing every valid subarray <code>[L..R]</code>, removing it, and inserting it at every possible position.",
    "Stop as soon as you dequeue <code>nums2</code>, and return its associated operation count."
  ]
}
