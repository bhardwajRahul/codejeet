{
  "id": "2415",
  "title": "Reverse Odd Levels of Binary Tree",
  "slug": "reverse-odd-levels-of-binary-tree",
  "difficulty": "Medium",
  "category": "Algorithms",
  "content_html": "<p>Given the <code>root</code> of a <strong>perfect</strong> binary tree, reverse the node values at each <strong>odd</strong> level of the tree.</p>\n\n<ul>\n\t<li>For example, suppose the node values at level 3 are <code>[2,1,3,4,7,11,29,18]</code>, then it should become <code>[18,29,11,7,4,3,1,2]</code>.</li>\n</ul>\n\n<p>Return <em>the root of the reversed tree</em>.</p>\n\n<p>A binary tree is <strong>perfect</strong> if all parent nodes have two children and all leaves are on the same level.</p>\n\n<p>The <strong>level</strong> of a node is the number of edges along the path between it and the root node.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/28/first_case1.png\" style=\"width: 626px; height: 191px;\" />\n<pre>\n<strong>Input:</strong> root = [2,3,5,8,13,21,34]\n<strong>Output:</strong> [2,5,3,8,13,21,34]\n<strong>Explanation:</strong> \nThe tree has only one odd level.\nThe nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/28/second_case3.png\" style=\"width: 591px; height: 111px;\" />\n<pre>\n<strong>Input:</strong> root = [7,13,11]\n<strong>Output:</strong> [7,11,13]\n<strong>Explanation:</strong> \nThe nodes at level 1 are 13, 11, which are reversed and become 11, 13.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\n<strong>Output:</strong> [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\n<strong>Explanation:</strong> \nThe odd levels have non-zero values.\nThe nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\nThe nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 2<sup>14</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>root</code> is a <strong>perfect</strong> binary tree.</li>\n</ul>\n",
  "content_markdown": "Given the `root` of a **perfect** binary tree, reverse the node values at each **odd** level of the tree.\n\n  * For example, suppose the node values at level 3 are `[2,1,3,4,7,11,29,18]`, then it should become `[18,29,11,7,4,3,1,2]`.\n\n\n\nReturn _the root of the reversed tree_.\n\nA binary tree is **perfect** if all parent nodes have two children and all leaves are on the same level.\n\nThe **level** of a node is the number of edges along the path between it and the root node.\n\n \n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/07/28/first_case1.png)\n    \n    \n    **Input:** root = [2,3,5,8,13,21,34]\n    **Output:** [2,5,3,8,13,21,34]\n    **Explanation:** \n    The tree has only one odd level.\n    The nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/07/28/second_case3.png)\n    \n    \n    **Input:** root = [7,13,11]\n    **Output:** [7,11,13]\n    **Explanation:** \n    The nodes at level 1 are 13, 11, which are reversed and become 11, 13.\n    \n\n**Example 3:**\n    \n    \n    **Input:** root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\n    **Output:** [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\n    **Explanation:** \n    The odd levels have non-zero values.\n    The nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\n    The nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal.\n    \n\n \n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1, 214]`.\n  * `0 <= Node.val <= 105`\n  * `root` is a **perfect** binary tree.",
  "question": "Given the `root` of a **perfect** binary tree, reverse the node values at each **odd** level of the tree.\n\n  * For example, suppose the node values at level 3 are `[2,1,3,4,7,11,29,18]`, then it should become `[18,29,11,7,4,3,1,2]`.\n\n\n\nReturn _the root of the reversed tree_.\n\nA binary tree is **perfect** if all parent nodes have two children and all leaves are on the same level.\n\nThe **level** of a node is the number of edges along the path between it and the root node.",
  "examples": "**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/07/28/first_case1.png)\n    \n    \n    **Input:** root = [2,3,5,8,13,21,34]\n    **Output:** [2,5,3,8,13,21,34]\n    **Explanation:** \n    The tree has only one odd level.\n    The nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/07/28/second_case3.png)\n    \n    \n    **Input:** root = [7,13,11]\n    **Output:** [7,11,13]\n    **Explanation:** \n    The nodes at level 1 are 13, 11, which are reversed and become 11, 13.\n    \n\n**Example 3:**\n    \n    \n    **Input:** root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\n    **Output:** [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\n    **Explanation:** \n    The odd levels have non-zero values.\n    The nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\n    The nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal.",
  "constraints": "**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1, 214]`.\n  * `0 <= Node.val <= 105`\n  * `root` is a **perfect** binary tree.",
  "topics": ["Tree", "Depth-First Search", "Breadth-First Search", "Binary Tree"],
  "total_accepted": 185552,
  "total_submissions": 214095,
  "acceptance_rate": "86.7%",
  "similar_questions": [
    {
      "title": "Invert Binary Tree",
      "slug": "invert-binary-tree",
      "difficulty": "Easy",
      "url": "https://leetcode.com/problems/invert-binary-tree/"
    }
  ],
  "hints": [
    "Try to solve recursively for each level independently.",
    "While performing a depth-first search, pass the left and right nodes (which should be paired) to the next level. If the current level is odd, then reverse their values, or else recursively move to the next level."
  ]
}
