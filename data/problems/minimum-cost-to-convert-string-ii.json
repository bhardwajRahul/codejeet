{
  "id": "2977",
  "title": "Minimum Cost to Convert String II",
  "slug": "minimum-cost-to-convert-string-ii",
  "difficulty": "Hard",
  "category": "Algorithms",
  "content_html": "<p>You are given two <strong>0-indexed</strong> strings <code>source</code> and <code>target</code>, both of length <code>n</code> and consisting of <strong>lowercase</strong> English characters. You are also given two <strong>0-indexed</strong> string arrays <code>original</code> and <code>changed</code>, and an integer array <code>cost</code>, where <code>cost[i]</code> represents the cost of converting the string <code>original[i]</code> to the string <code>changed[i]</code>.</p>\n\n<p>You start with the string <code>source</code>. In one operation, you can pick a <strong>substring</strong> <code>x</code> from the string, and change it to <code>y</code> at a cost of <code>z</code> <strong>if</strong> there exists <strong>any</strong> index <code>j</code> such that <code>cost[j] == z</code>, <code>original[j] == x</code>, and <code>changed[j] == y</code>. You are allowed to do <strong>any</strong> number of operations, but any pair of operations must satisfy <strong>either</strong> of these two conditions:</p>\n\n<ul>\n\t<li>The substrings picked in the operations are <code>source[a..b]</code> and <code>source[c..d]</code> with either <code>b &lt; c</code> <strong>or</strong> <code>d &lt; a</code>. In other words, the indices picked in both operations are <strong>disjoint</strong>.</li>\n\t<li>The substrings picked in the operations are <code>source[a..b]</code> and <code>source[c..d]</code> with <code>a == c</code> <strong>and</strong> <code>b == d</code>. In other words, the indices picked in both operations are <strong>identical</strong>.</li>\n</ul>\n\n<p>Return <em>the <strong>minimum</strong> cost to convert the string </em><code>source</code><em> to the string </em><code>target</code><em> using <strong>any</strong> number of operations</em>. <em>If it is impossible to convert</em> <code>source</code> <em>to</em> <code>target</code>,<em> return</em> <code>-1</code>.</p>\n\n<p><strong>Note</strong> that there may exist indices <code>i</code>, <code>j</code> such that <code>original[j] == original[i]</code> and <code>changed[j] == changed[i]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> source = &quot;abcd&quot;, target = &quot;acbe&quot;, original = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;e&quot;,&quot;d&quot;], changed = [&quot;b&quot;,&quot;c&quot;,&quot;b&quot;,&quot;e&quot;,&quot;b&quot;,&quot;e&quot;], cost = [2,5,5,1,2,20]\n<strong>Output:</strong> 28\n<strong>Explanation:</strong> To convert &quot;abcd&quot; to &quot;acbe&quot;, do the following operations:\n- Change substring source[1..1] from &quot;b&quot; to &quot;c&quot; at a cost of 5.\n- Change substring source[2..2] from &quot;c&quot; to &quot;e&quot; at a cost of 1.\n- Change substring source[2..2] from &quot;e&quot; to &quot;b&quot; at a cost of 2.\n- Change substring source[3..3] from &quot;d&quot; to &quot;e&quot; at a cost of 20.\nThe total cost incurred is 5 + 1 + 2 + 20 = 28. \nIt can be shown that this is the minimum possible cost.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> source = &quot;abcdefgh&quot;, target = &quot;acdeeghh&quot;, original = [&quot;bcd&quot;,&quot;fgh&quot;,&quot;thh&quot;], changed = [&quot;cde&quot;,&quot;thh&quot;,&quot;ghh&quot;], cost = [1,3,5]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> To convert &quot;abcdefgh&quot; to &quot;acdeeghh&quot;, do the following operations:\n- Change substring source[1..3] from &quot;bcd&quot; to &quot;cde&quot; at a cost of 1.\n- Change substring source[5..7] from &quot;fgh&quot; to &quot;thh&quot; at a cost of 3. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation.\n- Change substring source[5..7] from &quot;thh&quot; to &quot;ghh&quot; at a cost of 5. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation, and identical with indices picked in the second operation.\nThe total cost incurred is 1 + 3 + 5 = 9.\nIt can be shown that this is the minimum possible cost.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> source = &quot;abcdefgh&quot;, target = &quot;addddddd&quot;, original = [&quot;bcd&quot;,&quot;defgh&quot;], changed = [&quot;ddd&quot;,&quot;ddddd&quot;], cost = [100,1578]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> It is impossible to convert &quot;abcdefgh&quot; to &quot;addddddd&quot;.\nIf you select substring source[1..3] as the first operation to change &quot;abcdefgh&quot; to &quot;adddefgh&quot;, you cannot select substring source[3..7] as the second operation because it has a common index, 3, with the first operation.\nIf you select substring source[3..7] as the first operation to change &quot;abcdefgh&quot; to &quot;abcddddd&quot;, you cannot select substring source[1..3] as the second operation because it has a common index, 3, with the first operation.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= source.length == target.length &lt;= 1000</code></li>\n\t<li><code>source</code>, <code>target</code> consist only of lowercase English characters.</li>\n\t<li><code>1 &lt;= cost.length == original.length == changed.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= original[i].length == changed[i].length &lt;= source.length</code></li>\n\t<li><code>original[i]</code>, <code>changed[i]</code> consist only of lowercase English characters.</li>\n\t<li><code>original[i] != changed[i]</code></li>\n\t<li><code>1 &lt;= cost[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
  "content_markdown": "You are given two **0-indexed** strings `source` and `target`, both of length `n` and consisting of **lowercase** English characters. You are also given two **0-indexed** string arrays `original` and `changed`, and an integer array `cost`, where `cost[i]` represents the cost of converting the string `original[i]` to the string `changed[i]`.\n\nYou start with the string `source`. In one operation, you can pick a **substring** `x` from the string, and change it to `y` at a cost of `z` **if** there exists **any** index `j` such that `cost[j] == z`, `original[j] == x`, and `changed[j] == y`. You are allowed to do **any** number of operations, but any pair of operations must satisfy **either** of these two conditions:\n\n  * The substrings picked in the operations are `source[a..b]` and `source[c..d]` with either `b < c` **or** `d < a`. In other words, the indices picked in both operations are **disjoint**.\n  * The substrings picked in the operations are `source[a..b]` and `source[c..d]` with `a == c` **and** `b == d`. In other words, the indices picked in both operations are **identical**.\n\n\n\nReturn _the**minimum** cost to convert the string _`source` _to the string_`target` _using**any** number of operations_. _If it is impossible to convert_ `source` _to_ `target`,_return_ `-1`.\n\n**Note** that there may exist indices `i`, `j` such that `original[j] == original[i]` and `changed[j] == changed[i]`.\n\n \n\n**Example 1:**\n    \n    \n    **Input:** source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]\n    **Output:** 28\n    **Explanation:** To convert \"abcd\" to \"acbe\", do the following operations:\n    - Change substring source[1..1] from \"b\" to \"c\" at a cost of 5.\n    - Change substring source[2..2] from \"c\" to \"e\" at a cost of 1.\n    - Change substring source[2..2] from \"e\" to \"b\" at a cost of 2.\n    - Change substring source[3..3] from \"d\" to \"e\" at a cost of 20.\n    The total cost incurred is 5 + 1 + 2 + 20 = 28. \n    It can be shown that this is the minimum possible cost.\n    \n\n**Example 2:**\n    \n    \n    **Input:** source = \"abcdefgh\", target = \"acdeeghh\", original = [\"bcd\",\"fgh\",\"thh\"], changed = [\"cde\",\"thh\",\"ghh\"], cost = [1,3,5]\n    **Output:** 9\n    **Explanation:** To convert \"abcdefgh\" to \"acdeeghh\", do the following operations:\n    - Change substring source[1..3] from \"bcd\" to \"cde\" at a cost of 1.\n    - Change substring source[5..7] from \"fgh\" to \"thh\" at a cost of 3. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation.\n    - Change substring source[5..7] from \"thh\" to \"ghh\" at a cost of 5. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation, and identical with indices picked in the second operation.\n    The total cost incurred is 1 + 3 + 5 = 9.\n    It can be shown that this is the minimum possible cost.\n    \n\n**Example 3:**\n    \n    \n    **Input:** source = \"abcdefgh\", target = \"addddddd\", original = [\"bcd\",\"defgh\"], changed = [\"ddd\",\"ddddd\"], cost = [100,1578]\n    **Output:** -1\n    **Explanation:** It is impossible to convert \"abcdefgh\" to \"addddddd\".\n    If you select substring source[1..3] as the first operation to change \"abcdefgh\" to \"adddefgh\", you cannot select substring source[3..7] as the second operation because it has a common index, 3, with the first operation.\n    If you select substring source[3..7] as the first operation to change \"abcdefgh\" to \"abcddddd\", you cannot select substring source[1..3] as the second operation because it has a common index, 3, with the first operation.\n    \n\n \n\n**Constraints:**\n\n  * `1 <= source.length == target.length <= 1000`\n  * `source`, `target` consist only of lowercase English characters.\n  * `1 <= cost.length == original.length == changed.length <= 100`\n  * `1 <= original[i].length == changed[i].length <= source.length`\n  * `original[i]`, `changed[i]` consist only of lowercase English characters.\n  * `original[i] != changed[i]`\n  * `1 <= cost[i] <= 106`",
  "question": "You are given two **0-indexed** strings `source` and `target`, both of length `n` and consisting of **lowercase** English characters. You are also given two **0-indexed** string arrays `original` and `changed`, and an integer array `cost`, where `cost[i]` represents the cost of converting the string `original[i]` to the string `changed[i]`.\n\nYou start with the string `source`. In one operation, you can pick a **substring** `x` from the string, and change it to `y` at a cost of `z` **if** there exists **any** index `j` such that `cost[j] == z`, `original[j] == x`, and `changed[j] == y`. You are allowed to do **any** number of operations, but any pair of operations must satisfy **either** of these two conditions:\n\n  * The substrings picked in the operations are `source[a..b]` and `source[c..d]` with either `b < c` **or** `d < a`. In other words, the indices picked in both operations are **disjoint**.\n  * The substrings picked in the operations are `source[a..b]` and `source[c..d]` with `a == c` **and** `b == d`. In other words, the indices picked in both operations are **identical**.\n\n\n\nReturn _the**minimum** cost to convert the string _`source` _to the string_`target` _using**any** number of operations_. _If it is impossible to convert_ `source` _to_ `target`,_return_ `-1`.\n\n**Note** that there may exist indices `i`, `j` such that `original[j] == original[i]` and `changed[j] == changed[i]`.",
  "examples": "**Example 1:**\n    \n    \n    **Input:** source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]\n    **Output:** 28\n    **Explanation:** To convert \"abcd\" to \"acbe\", do the following operations:\n    - Change substring source[1..1] from \"b\" to \"c\" at a cost of 5.\n    - Change substring source[2..2] from \"c\" to \"e\" at a cost of 1.\n    - Change substring source[2..2] from \"e\" to \"b\" at a cost of 2.\n    - Change substring source[3..3] from \"d\" to \"e\" at a cost of 20.\n    The total cost incurred is 5 + 1 + 2 + 20 = 28. \n    It can be shown that this is the minimum possible cost.\n    \n\n**Example 2:**\n    \n    \n    **Input:** source = \"abcdefgh\", target = \"acdeeghh\", original = [\"bcd\",\"fgh\",\"thh\"], changed = [\"cde\",\"thh\",\"ghh\"], cost = [1,3,5]\n    **Output:** 9\n    **Explanation:** To convert \"abcdefgh\" to \"acdeeghh\", do the following operations:\n    - Change substring source[1..3] from \"bcd\" to \"cde\" at a cost of 1.\n    - Change substring source[5..7] from \"fgh\" to \"thh\" at a cost of 3. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation.\n    - Change substring source[5..7] from \"thh\" to \"ghh\" at a cost of 5. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation, and identical with indices picked in the second operation.\n    The total cost incurred is 1 + 3 + 5 = 9.\n    It can be shown that this is the minimum possible cost.\n    \n\n**Example 3:**\n    \n    \n    **Input:** source = \"abcdefgh\", target = \"addddddd\", original = [\"bcd\",\"defgh\"], changed = [\"ddd\",\"ddddd\"], cost = [100,1578]\n    **Output:** -1\n    **Explanation:** It is impossible to convert \"abcdefgh\" to \"addddddd\".\n    If you select substring source[1..3] as the first operation to change \"abcdefgh\" to \"adddefgh\", you cannot select substring source[3..7] as the second operation because it has a common index, 3, with the first operation.\n    If you select substring source[3..7] as the first operation to change \"abcdefgh\" to \"abcddddd\", you cannot select substring source[1..3] as the second operation because it has a common index, 3, with the first operation.",
  "constraints": "**Constraints:**\n\n  * `1 <= source.length == target.length <= 1000`\n  * `source`, `target` consist only of lowercase English characters.\n  * `1 <= cost.length == original.length == changed.length <= 100`\n  * `1 <= original[i].length == changed[i].length <= source.length`\n  * `original[i]`, `changed[i]` consist only of lowercase English characters.\n  * `original[i] != changed[i]`\n  * `1 <= cost[i] <= 106`",
  "topics": ["Array", "String", "Dynamic Programming", "Graph Theory", "Trie", "Shortest Path"],
  "total_accepted": 63962,
  "total_submissions": 107187,
  "acceptance_rate": "59.7%",
  "similar_questions": [
    {
      "title": "Can Convert String in K Moves",
      "slug": "can-convert-string-in-k-moves",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/can-convert-string-in-k-moves/"
    },
    {
      "title": "Minimum Moves to Convert String",
      "slug": "minimum-moves-to-convert-string",
      "difficulty": "Easy",
      "url": "https://leetcode.com/problems/minimum-moves-to-convert-string/"
    },
    {
      "title": "Minimum Number of Valid Strings to Form Target II",
      "slug": "minimum-number-of-valid-strings-to-form-target-ii",
      "difficulty": "Hard",
      "url": "https://leetcode.com/problems/minimum-number-of-valid-strings-to-form-target-ii/"
    },
    {
      "title": "Minimum Number of Valid Strings to Form Target I",
      "slug": "minimum-number-of-valid-strings-to-form-target-i",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/minimum-number-of-valid-strings-to-form-target-i/"
    }
  ],
  "hints": [
    "Give each unique string in <code>original</code> and <code>changed</code> arrays a unique id. There are at most <code>2 * m</code> unique strings in total where <code>m</code> is the length of the arrays. We can put them into a hash map to assign ids.",
    "We can pre-compute the smallest costs between all pairs of unique strings using Floyd Warshall algorithm in <code>O(m ^ 3)</code> time complexity.",
    "Let <code>dp[i]</code> be the smallest cost to change the first <code>i</code> characters (prefix) of <code>source</code> into <code>target</code>, leaving the suffix untouched.\r\nWe have <code>dp[0] = 0</code>.\r\n<code>dp[i] = min(\r\ndp[i - 1] if (source[i - 1] == target[i - 1]),\r\ndp[j-1] + cost[x][y] where x is the id of source[j..(i - 1)] and y is the id of target e[j..(i - 1)])\r\n)</code>.\r\nIf neither of the two conditions is satisfied, <code>dp[i] = infinity</code>.",
    "We can use Trie to check for the second condition in <code>O(1)</code>.",
    "The answer is <code>dp[n]</code> where <code>n</code> is <code>source.length</code>."
  ]
}
