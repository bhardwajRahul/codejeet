{
  "id": "1606",
  "title": "Find Servers That Handled Most Number of Requests",
  "slug": "find-servers-that-handled-most-number-of-requests",
  "difficulty": "Hard",
  "category": "Algorithms",
  "content_html": "<p>You have <code>k</code> servers numbered from <code>0</code> to <code>k-1</code> that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but <strong>cannot handle more than one request at a time</strong>. The requests are assigned to servers according to a specific algorithm:</p>\n\n<ul>\n\t<li>The <code>i<sup>th</sup></code> (0-indexed) request arrives.</li>\n\t<li>If all servers are busy, the request is dropped (not handled at all).</li>\n\t<li>If the <code>(i % k)<sup>th</sup></code> server is available, assign the request to that server.</li>\n\t<li>Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the <code>i<sup>th</sup></code> server is busy, try to assign the request to the <code>(i+1)<sup>th</sup></code> server, then the <code>(i+2)<sup>th</sup></code> server, and so on.</li>\n</ul>\n\n<p>You are given a <strong>strictly increasing</strong> array <code>arrival</code> of positive integers, where <code>arrival[i]</code> represents the arrival time of the <code>i<sup>th</sup></code> request, and another array <code>load</code>, where <code>load[i]</code> represents the load of the <code>i<sup>th</sup></code> request (the time it takes to complete). Your goal is to find the <strong>busiest server(s)</strong>. A server is considered <strong>busiest</strong> if it handled the most number of requests successfully among all the servers.</p>\n\n<p>Return <em>a list containing the IDs (0-indexed) of the <strong>busiest server(s)</strong></em>. You may return the IDs in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/08/load-1.png\" style=\"width: 389px; height: 221px;\" />\n<pre>\n<strong>Input:</strong> k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] \n<strong>Output:</strong> [1] \n<strong>Explanation:</strong> \nAll of the servers start out available.\nThe first 3 requests are handled by the first 3 servers in order.\nRequest 3 comes in. Server 0 is busy, so it&#39;s assigned to the next available server, which is 1.\nRequest 4 comes in. It cannot be handled since all servers are busy, so it is dropped.\nServers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, arrival = [1,2,3,4], load = [1,2,1,2]\n<strong>Output:</strong> [0]\n<strong>Explanation:</strong> \nThe first 3 requests are handled by first 3 servers.\nRequest 3 comes in. It is handled by server 0 since the server is available.\nServer 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, arrival = [1,2,3], load = [10,12,11]\n<strong>Output:</strong> [0,1,2]\n<strong>Explanation:</strong> Each server handles a single request, so they are all considered the busiest.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arrival.length, load.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>arrival.length == load.length</code></li>\n\t<li><code>1 &lt;= arrival[i], load[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>arrival</code> is <strong>strictly increasing</strong>.</li>\n</ul>\n",
  "content_markdown": "You have `k` servers numbered from `0` to `k-1` that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but **cannot handle more than one request at a time**. The requests are assigned to servers according to a specific algorithm:\n\n  * The `ith` (0-indexed) request arrives.\n  * If all servers are busy, the request is dropped (not handled at all).\n  * If the `(i % k)th` server is available, assign the request to that server.\n  * Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the `ith` server is busy, try to assign the request to the `(i+1)th` server, then the `(i+2)th` server, and so on.\n\n\n\nYou are given a **strictly increasing** array `arrival` of positive integers, where `arrival[i]` represents the arrival time of the `ith` request, and another array `load`, where `load[i]` represents the load of the `ith` request (the time it takes to complete). Your goal is to find the **busiest server(s)**. A server is considered **busiest** if it handled the most number of requests successfully among all the servers.\n\nReturn _a list containing the IDs (0-indexed) of the**busiest server(s)**_. You may return the IDs in any order.\n\n \n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/08/load-1.png)\n    \n    \n    **Input:** k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] \n    **Output:** [1] \n    **Explanation:** \n    All of the servers start out available.\n    The first 3 requests are handled by the first 3 servers in order.\n    Request 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1.\n    Request 4 comes in. It cannot be handled since all servers are busy, so it is dropped.\n    Servers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.\n    \n\n**Example 2:**\n    \n    \n    **Input:** k = 3, arrival = [1,2,3,4], load = [1,2,1,2]\n    **Output:** [0]\n    **Explanation:** \n    The first 3 requests are handled by first 3 servers.\n    Request 3 comes in. It is handled by server 0 since the server is available.\n    Server 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.\n    \n\n**Example 3:**\n    \n    \n    **Input:** k = 3, arrival = [1,2,3], load = [10,12,11]\n    **Output:** [0,1,2]\n    **Explanation:** Each server handles a single request, so they are all considered the busiest.\n    \n\n \n\n**Constraints:**\n\n  * `1 <= k <= 105`\n  * `1 <= arrival.length, load.length <= 105`\n  * `arrival.length == load.length`\n  * `1 <= arrival[i], load[i] <= 109`\n  * `arrival` is **strictly increasing**.",
  "question": "You have `k` servers numbered from `0` to `k-1` that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but **cannot handle more than one request at a time**. The requests are assigned to servers according to a specific algorithm:\n\n  * The `ith` (0-indexed) request arrives.\n  * If all servers are busy, the request is dropped (not handled at all).\n  * If the `(i % k)th` server is available, assign the request to that server.\n  * Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the `ith` server is busy, try to assign the request to the `(i+1)th` server, then the `(i+2)th` server, and so on.\n\n\n\nYou are given a **strictly increasing** array `arrival` of positive integers, where `arrival[i]` represents the arrival time of the `ith` request, and another array `load`, where `load[i]` represents the load of the `ith` request (the time it takes to complete). Your goal is to find the **busiest server(s)**. A server is considered **busiest** if it handled the most number of requests successfully among all the servers.\n\nReturn _a list containing the IDs (0-indexed) of the**busiest server(s)**_. You may return the IDs in any order.",
  "examples": "**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/08/load-1.png)\n    \n    \n    **Input:** k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] \n    **Output:** [1] \n    **Explanation:** \n    All of the servers start out available.\n    The first 3 requests are handled by the first 3 servers in order.\n    Request 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1.\n    Request 4 comes in. It cannot be handled since all servers are busy, so it is dropped.\n    Servers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.\n    \n\n**Example 2:**\n    \n    \n    **Input:** k = 3, arrival = [1,2,3,4], load = [1,2,1,2]\n    **Output:** [0]\n    **Explanation:** \n    The first 3 requests are handled by first 3 servers.\n    Request 3 comes in. It is handled by server 0 since the server is available.\n    Server 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.\n    \n\n**Example 3:**\n    \n    \n    **Input:** k = 3, arrival = [1,2,3], load = [10,12,11]\n    **Output:** [0,1,2]\n    **Explanation:** Each server handles a single request, so they are all considered the busiest.",
  "constraints": "**Constraints:**\n\n  * `1 <= k <= 105`\n  * `1 <= arrival.length, load.length <= 105`\n  * `arrival.length == load.length`\n  * `1 <= arrival[i], load[i] <= 109`\n  * `arrival` is **strictly increasing**.",
  "topics": ["Array", "Heap (Priority Queue)", "Simulation", "Ordered Set"],
  "total_accepted": 28220,
  "total_submissions": 62397,
  "acceptance_rate": "45.2%",
  "similar_questions": [
    {
      "title": "Meeting Rooms III",
      "slug": "meeting-rooms-iii",
      "difficulty": "Hard",
      "url": "https://leetcode.com/problems/meeting-rooms-iii/"
    }
  ],
  "hints": [
    "To speed up the next available server search, keep track of the available servers in a sorted structure such as an ordered set.",
    "To determine if a server is available, keep track of the end times for each task in a heap and add the server to the available set once the soonest task ending time is less than or equal to the next task to add."
  ]
}
