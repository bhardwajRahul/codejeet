{
  "id": "3797",
  "title": "Count Routes to Climb a Rectangular Grid",
  "slug": "count-routes-to-climb-a-rectangular-grid",
  "difficulty": "Hard",
  "category": "Algorithms",
  "content_html": "<p>You are given a string array <code>grid</code> of size <code>n</code>, where each string <code>grid[i]</code> has length <code>m</code>. The character <code>grid[i][j]</code> is one of the following symbols:</p>\n\n<ul>\n\t<li><code>&#39;.&#39;</code>: The cell is available.</li>\n\t<li><code>&#39;#&#39;</code>: The cell is blocked.</li>\n</ul>\n\n<p>You want to count the number of different routes to climb <code>grid</code>. Each route must start from <em>any cell</em> in the bottom row (row <code>n - 1</code>) and end in the top row (row 0).</p>\n\n<p>However, there are some constraints on the route.</p>\n\n<ul>\n\t<li>You can only move from one available cell to <strong>another</strong> available cell.</li>\n\t<li>The <strong>Euclidean distance</strong> of each move is <strong>at most</strong> <code>d</code>, where <code>d</code> is an integer parameter given to you. The Euclidean distance between two cells <code>(r1, c1)</code>, <code>(r2, c2)</code> is <code>sqrt((r1 - r2)<sup>2</sup> + (c1 - c2)<sup>2</sup>)</code>.</li>\n\t<li>Each move either stays on the same row or moves to the row directly above (from row <code>r</code> to <code>r - 1</code>).</li>\n\t<li>You cannot stay on the same row for two consecutive turns. If you stay on the same row in a move (and this move is not the last move), your next move must go to the row above.</li>\n</ul>\n\n<p>Return an integer denoting the number of such routes. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">grid = [&quot;..&quot;,&quot;#.&quot;], d = 1</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>We label the cells we visit in the routes sequentially, starting from 1. The two routes are:</p>\n\n<pre>\n.2\n#1\n</pre>\n\n<pre>\n32\n#1\n</pre>\n\n<p>We can move from the cell (1, 1) to the cell (0, 1) because the Euclidean distance is <code>sqrt((1 - 0)<sup>2</sup> + (1 - 1)<sup>2</sup>) = sqrt(1) &lt;= d</code>.</p>\n\n<p>However, we cannot move from the cell (1, 1) to the cell (0, 0) because the Euclidean distance is <code>sqrt((1 - 0)<sup>2</sup> + (1 - 0)<sup>2</sup>) = sqrt(2) &gt; d</code>.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">grid = [&quot;..&quot;,&quot;#.&quot;], d = 2</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">4</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Two of the routes are given in example 1. The other two routes are:</p>\n\n<pre>\n2.\n#1\n</pre>\n\n<pre>\n23\n#1\n</pre>\n\n<p>Note that we can move from (1, 1) to (0, 0) because the Euclidean distance is <code>sqrt(2) &lt;= d</code>.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">grid = [&quot;#&quot;], d = 750</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">0</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>We cannot choose any cell as the starting cell. Therefore, there are no routes.</p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">grid = [&quot;..&quot;], d = 1</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">4</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The possible routes are:</p>\n\n<pre>\n.1\n</pre>\n\n<pre>\n1.\n</pre>\n\n<pre>\n12\n</pre>\n\n<pre>\n21\n</pre>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == grid.length &lt;= 750</code></li>\n\t<li><code>1 &lt;= m == grid[i].length &lt;= 750</code></li>\n\t<li><code>grid[i][j]</code> is <code>&#39;.&#39;</code> or <code>&#39;#&#39;</code>.</li>\n\t<li><code>1 &lt;= d &lt;= 750</code></li>\n</ul>\n",
  "content_markdown": "You are given a string array `grid` of size `n`, where each string `grid[i]` has length `m`. The character `grid[i][j]` is one of the following symbols:\n\n  * `'.'`: The cell is available.\n  * `'#'`: The cell is blocked.\n\n\n\nYou want to count the number of different routes to climb `grid`. Each route must start from _any cell_ in the bottom row (row `n - 1`) and end in the top row (row 0).\n\nHowever, there are some constraints on the route.\n\n  * You can only move from one available cell to **another** available cell.\n  * The **Euclidean distance** of each move is **at most** `d`, where `d` is an integer parameter given to you. The Euclidean distance between two cells `(r1, c1)`, `(r2, c2)` is `sqrt((r1 - r2)2 + (c1 - c2)2)`.\n  * Each move either stays on the same row or moves to the row directly above (from row `r` to `r - 1`).\n  * You cannot stay on the same row for two consecutive turns. If you stay on the same row in a move (and this move is not the last move), your next move must go to the row above.\n\n\n\nReturn an integer denoting the number of such routes. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n \n\n**Example 1:**\n\n**Input:** grid = [\"..\",\"#.\"], d = 1\n\n**Output:** 2\n\n**Explanation:**\n\nWe label the cells we visit in the routes sequentially, starting from 1. The two routes are:\n    \n    \n    .2\n    #1\n    \n    \n    \n    32\n    #1\n    \n\nWe can move from the cell (1, 1) to the cell (0, 1) because the Euclidean distance is `sqrt((1 - 0)2 + (1 - 1)2) = sqrt(1) <= d`.\n\nHowever, we cannot move from the cell (1, 1) to the cell (0, 0) because the Euclidean distance is `sqrt((1 - 0)2 + (1 - 0)2) = sqrt(2) > d`.\n\n**Example 2:**\n\n**Input:** grid = [\"..\",\"#.\"], d = 2\n\n**Output:** 4\n\n**Explanation:**\n\nTwo of the routes are given in example 1. The other two routes are:\n    \n    \n    2.\n    #1\n    \n    \n    \n    23\n    #1\n    \n\nNote that we can move from (1, 1) to (0, 0) because the Euclidean distance is `sqrt(2) <= d`.\n\n**Example 3:**\n\n**Input:** grid = [\"#\"], d = 750\n\n**Output:** 0\n\n**Explanation:**\n\nWe cannot choose any cell as the starting cell. Therefore, there are no routes.\n\n**Example 4:**\n\n**Input:** grid = [\"..\"], d = 1\n\n**Output:** 4\n\n**Explanation:**\n\nThe possible routes are:\n    \n    \n    .1\n    \n    \n    \n    1.\n    \n    \n    \n    12\n    \n    \n    \n    21\n    \n\n \n\n**Constraints:**\n\n  * `1 <= n == grid.length <= 750`\n  * `1 <= m == grid[i].length <= 750`\n  * `grid[i][j]` is `'.'` or `'#'`.\n  * `1 <= d <= 750`",
  "question": "You are given a string array `grid` of size `n`, where each string `grid[i]` has length `m`. The character `grid[i][j]` is one of the following symbols:\n\n  * `'.'`: The cell is available.\n  * `'#'`: The cell is blocked.\n\n\n\nYou want to count the number of different routes to climb `grid`. Each route must start from _any cell_ in the bottom row (row `n - 1`) and end in the top row (row 0).\n\nHowever, there are some constraints on the route.\n\n  * You can only move from one available cell to **another** available cell.\n  * The **Euclidean distance** of each move is **at most** `d`, where `d` is an integer parameter given to you. The Euclidean distance between two cells `(r1, c1)`, `(r2, c2)` is `sqrt((r1 - r2)2 + (c1 - c2)2)`.\n  * Each move either stays on the same row or moves to the row directly above (from row `r` to `r - 1`).\n  * You cannot stay on the same row for two consecutive turns. If you stay on the same row in a move (and this move is not the last move), your next move must go to the row above.\n\n\n\nReturn an integer denoting the number of such routes. Since the answer may be very large, return it **modulo** `109 + 7`.",
  "examples": "**Example 1:**\n\n**Input:** grid = [\"..\",\"#.\"], d = 1\n\n**Output:** 2\n\n**Explanation:**\n\nWe label the cells we visit in the routes sequentially, starting from 1. The two routes are:\n    \n    \n    .2\n    #1\n    \n    \n    \n    32\n    #1\n    \n\nWe can move from the cell (1, 1) to the cell (0, 1) because the Euclidean distance is `sqrt((1 - 0)2 + (1 - 1)2) = sqrt(1) <= d`.\n\nHowever, we cannot move from the cell (1, 1) to the cell (0, 0) because the Euclidean distance is `sqrt((1 - 0)2 + (1 - 0)2) = sqrt(2) > d`.\n\n**Example 2:**\n\n**Input:** grid = [\"..\",\"#.\"], d = 2\n\n**Output:** 4\n\n**Explanation:**\n\nTwo of the routes are given in example 1. The other two routes are:\n    \n    \n    2.\n    #1\n    \n    \n    \n    23\n    #1\n    \n\nNote that we can move from (1, 1) to (0, 0) because the Euclidean distance is `sqrt(2) <= d`.\n\n**Example 3:**\n\n**Input:** grid = [\"#\"], d = 750\n\n**Output:** 0\n\n**Explanation:**\n\nWe cannot choose any cell as the starting cell. Therefore, there are no routes.\n\n**Example 4:**\n\n**Input:** grid = [\"..\"], d = 1\n\n**Output:** 4\n\n**Explanation:**\n\nThe possible routes are:\n    \n    \n    .1\n    \n    \n    \n    1.\n    \n    \n    \n    12\n    \n    \n    \n    21",
  "constraints": "**Constraints:**\n\n  * `1 <= n == grid.length <= 750`\n  * `1 <= m == grid[i].length <= 750`\n  * `grid[i][j]` is `'.'` or `'#'`.\n  * `1 <= d <= 750`",
  "topics": ["Array", "Dynamic Programming", "Matrix", "Prefix Sum"],
  "total_accepted": 3497,
  "total_submissions": 14584,
  "acceptance_rate": "24.0%",
  "similar_questions": [],
  "hints": [
    "Use dynamic programming.",
    "Let <code>dp[r][c][0]</code> be the number of ways to reach <code>(r, c)</code> where the last move came from row <code>r + 1</code> (moved up), and let <code>dp[r][c][1]</code> be the number of ways where the last move stayed on row <code>r</code>.",
    "Make computations faster using prefix sums over columns to aggregate contributions from cells within Euclidean distance <code>d</code>.",
    "Combine <code>dp[r][c][0]</code> and <code>dp[r][c][1]</code> for all columns <code>c</code> in row <code>r</code> to produce the <code>dp</code> values used for row <code>r - 1</code>."
  ]
}
