{
  "id": "3650",
  "title": "Minimum Cost Path with Edge Reversals",
  "slug": "minimum-cost-path-with-edge-reversals",
  "difficulty": "Medium",
  "category": "Algorithms",
  "content_html": "<p>You are given a directed, weighted graph with <code>n</code> nodes labeled from 0 to <code>n - 1</code>, and an array <code>edges</code> where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> represents a directed edge from node <code>u<sub>i</sub></code> to node <code>v<sub>i</sub></code> with cost <code>w<sub>i</sub></code>.</p>\n\n<p>Each node <code>u<sub>i</sub></code> has a switch that can be used <strong>at most once</strong>: when you arrive at <code>u<sub>i</sub></code> and have not yet used its switch, you may activate it on one of its incoming edges <code>v<sub>i</sub> &rarr; u<sub>i</sub></code> reverse that edge to <code>u<sub>i</sub> &rarr; v<sub>i</sub></code> and <strong>immediately</strong> traverse it.</p>\n\n<p>The reversal is only valid for that single move, and using a reversed edge costs <code>2 * w<sub>i</sub></code>.</p>\n\n<p>Return the <strong>minimum</strong> total cost to travel from node 0 to node <code>n - 1</code>. If it is not possible, return -1.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 4, edges = [[0,1,3],[3,1,1],[2,3,4],[0,2,2]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">5</span></p>\n\n<p><strong>Explanation: </strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2025/05/07/e1drawio.png\" style=\"width: 171px; height: 111px;\" /></strong></p>\n\n<ul>\n\t<li>Use the path <code>0 &rarr; 1</code> (cost 3).</li>\n\t<li>At node 1 reverse the original edge <code>3 &rarr; 1</code> into <code>1 &rarr; 3</code> and traverse it at cost <code>2 * 1 = 2</code>.</li>\n\t<li>Total cost is <code>3 + 2 = 5</code>.</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 4, edges = [[0,2,1],[2,1,1],[1,3,1],[2,3,3]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">3</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li>No reversal is needed. Take the path <code>0 &rarr; 2</code> (cost 1), then <code>2 &rarr; 1</code> (cost 1), then <code>1 &rarr; 3</code> (cost 1).</li>\n\t<li>Total cost is <code>1 + 1 + 1 = 3</code>.</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= w<sub>i</sub> &lt;= 1000</code></li>\n</ul>\n",
  "content_markdown": "You are given a directed, weighted graph with `n` nodes labeled from 0 to `n - 1`, and an array `edges` where `edges[i] = [ui, vi, wi]` represents a directed edge from node `ui` to node `vi` with cost `wi`.\n\nEach node `ui` has a switch that can be used **at most once** : when you arrive at `ui` and have not yet used its switch, you may activate it on one of its incoming edges `vi → ui` reverse that edge to `ui → vi` and **immediately** traverse it.\n\nThe reversal is only valid for that single move, and using a reversed edge costs `2 * wi`.\n\nReturn the **minimum** total cost to travel from node 0 to node `n - 1`. If it is not possible, return -1.\n\n \n\n**Example 1:**\n\n**Input:** n = 4, edges = [[0,1,3],[3,1,1],[2,3,4],[0,2,2]]\n\n**Output:** 5\n\n**Explanation:**\n\n**![](https://assets.leetcode.com/uploads/2025/05/07/e1drawio.png)**\n\n  * Use the path `0 → 1` (cost 3).\n  * At node 1 reverse the original edge `3 → 1` into `1 → 3` and traverse it at cost `2 * 1 = 2`.\n  * Total cost is `3 + 2 = 5`.\n\n\n\n**Example 2:**\n\n**Input:** n = 4, edges = [[0,2,1],[2,1,1],[1,3,1],[2,3,3]]\n\n**Output:** 3\n\n**Explanation:**\n\n  * No reversal is needed. Take the path `0 → 2` (cost 1), then `2 → 1` (cost 1), then `1 → 3` (cost 1).\n  * Total cost is `1 + 1 + 1 = 3`.\n\n\n\n \n\n**Constraints:**\n\n  * `2 <= n <= 5 * 104`\n  * `1 <= edges.length <= 105`\n  * `edges[i] = [ui, vi, wi]`\n  * `0 <= ui, vi <= n - 1`\n  * `1 <= wi <= 1000`",
  "question": "You are given a directed, weighted graph with `n` nodes labeled from 0 to `n - 1`, and an array `edges` where `edges[i] = [ui, vi, wi]` represents a directed edge from node `ui` to node `vi` with cost `wi`.\n\nEach node `ui` has a switch that can be used **at most once** : when you arrive at `ui` and have not yet used its switch, you may activate it on one of its incoming edges `vi → ui` reverse that edge to `ui → vi` and **immediately** traverse it.\n\nThe reversal is only valid for that single move, and using a reversed edge costs `2 * wi`.\n\nReturn the **minimum** total cost to travel from node 0 to node `n - 1`. If it is not possible, return -1.",
  "examples": "**Example 1:**\n\n**Input:** n = 4, edges = [[0,1,3],[3,1,1],[2,3,4],[0,2,2]]\n\n**Output:** 5\n\n**Explanation:**\n\n**![](https://assets.leetcode.com/uploads/2025/05/07/e1drawio.png)**\n\n  * Use the path `0 → 1` (cost 3).\n  * At node 1 reverse the original edge `3 → 1` into `1 → 3` and traverse it at cost `2 * 1 = 2`.\n  * Total cost is `3 + 2 = 5`.\n\n\n\n**Example 2:**\n\n**Input:** n = 4, edges = [[0,2,1],[2,1,1],[1,3,1],[2,3,3]]\n\n**Output:** 3\n\n**Explanation:**\n\n  * No reversal is needed. Take the path `0 → 2` (cost 1), then `2 → 1` (cost 1), then `1 → 3` (cost 1).\n  * Total cost is `1 + 1 + 1 = 3`.",
  "constraints": "**Constraints:**\n\n  * `2 <= n <= 5 * 104`\n  * `1 <= edges.length <= 105`\n  * `edges[i] = [ui, vi, wi]`\n  * `0 <= ui, vi <= n - 1`\n  * `1 <= wi <= 1000`",
  "topics": ["Graph Theory", "Heap (Priority Queue)", "Shortest Path"],
  "total_accepted": 101861,
  "total_submissions": 164768,
  "acceptance_rate": "61.8%",
  "similar_questions": [
    {
      "title": "Minimum Cost to Reach Destination in Time",
      "slug": "minimum-cost-to-reach-destination-in-time",
      "difficulty": "Hard",
      "url": "https://leetcode.com/problems/minimum-cost-to-reach-destination-in-time/"
    }
  ],
  "hints": [
    "Do we only need to reverse at most one edge for each node? If so, can we add reversed edges for each node and use the one that helps in the shortest path?",
    "Add reverse edges: <code>{u, v, w}</code> -> <code>{v, u, 2 * w}</code>, and use Dijkstra."
  ]
}
