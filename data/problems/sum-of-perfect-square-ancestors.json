{
  "id": "3715",
  "title": "Sum of Perfect Square Ancestors",
  "slug": "sum-of-perfect-square-ancestors",
  "difficulty": "Hard",
  "category": "Algorithms",
  "content_html": "<p>You are given an integer <code>n</code> and an undirected tree rooted at node 0 with <code>n</code> nodes numbered from 0 to <code>n - 1</code>. This is represented by a 2D array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates an undirected edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>.</p>\n\n<p>You are also given an integer array <code>nums</code>, where <code>nums[i]</code> is the positive integer assigned to node <code>i</code>.</p>\n\n<p>Define a value <code>t<sub>i</sub></code> as the number of <strong>ancestors</strong> of node <code>i</code> such that the product <code>nums[i] * nums[ancestor]</code> is a <strong><span data-keyword=\"perfect-square\">perfect square</span></strong>.</p>\n\n<p>Return the sum of all <code>t<sub>i</sub></code> values for all nodes <code>i</code> in range <code>[1, n - 1]</code>.</p>\n\n<p><strong>Note</strong>:</p>\n\n<ul>\n\t<li>In a rooted tree, the <strong>ancestors</strong> of node <code>i</code> are all nodes on the path from node <code>i</code> to the root node 0, <strong>excluding</strong> <code>i</code> itself.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 3, edges = [[0,1],[1,2]], nums = [2,8,2]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">3</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<table style=\"border: 1px solid black;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th style=\"border: 1px solid black;\"><code><strong>i</strong></code></th>\n\t\t\t<th style=\"border: 1px solid black;\"><strong>Ancestors</strong></th>\n\t\t\t<th style=\"border: 1px solid black;\"><code><strong>nums[i] * nums[ancestor]</strong></code></th>\n\t\t\t<th style=\"border: 1px solid black;\">Square Check</th>\n\t\t\t<th style=\"border: 1px solid black;\"><code><strong>t<sub>i</sub></strong></code></th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"border: 1px solid black;\">1</td>\n\t\t\t<td style=\"border: 1px solid black;\">[0]</td>\n\t\t\t<td style=\"border: 1px solid black;\"><code>nums[1] * nums[0] = 8 * 2 = 16</code></td>\n\t\t\t<td style=\"border: 1px solid black;\">16 is a perfect square</td>\n\t\t\t<td style=\"border: 1px solid black;\">1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 1px solid black;\">2</td>\n\t\t\t<td style=\"border: 1px solid black;\">[1, 0]</td>\n\t\t\t<td style=\"border: 1px solid black;\"><code>nums[2] * nums[1] = 2 * 8 = 16</code><br />\n\t\t\t<code>nums[2] * nums[0] = 2 * 2 = 4</code></td>\n\t\t\t<td style=\"border: 1px solid black;\">Both 4 and 16 are perfect squares</td>\n\t\t\t<td style=\"border: 1px solid black;\">2</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>Thus, the total number of valid ancestor pairs across all non-root nodes is <code>1 + 2 = 3</code>.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 3, edges = [[0,1],[0,2]], nums = [1,2,4]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">1</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<table style=\"border: 1px solid black;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th style=\"border: 1px solid black;\"><code><strong>i</strong></code></th>\n\t\t\t<th style=\"border: 1px solid black;\"><strong>Ancestors</strong></th>\n\t\t\t<th style=\"border: 1px solid black;\"><code><strong>nums[i] * nums[ancestor]</strong></code></th>\n\t\t\t<th style=\"border: 1px solid black;\">Square Check</th>\n\t\t\t<th style=\"border: 1px solid black;\"><code><strong>t<sub>i</sub></strong></code></th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"border: 1px solid black;\">1</td>\n\t\t\t<td style=\"border: 1px solid black;\">[0]</td>\n\t\t\t<td style=\"border: 1px solid black;\"><code>nums[1] * nums[0] = 2 * 1 = 2</code></td>\n\t\t\t<td style=\"border: 1px solid black;\">2 is <strong>not</strong> a perfect square</td>\n\t\t\t<td style=\"border: 1px solid black;\">0</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 1px solid black;\">2</td>\n\t\t\t<td style=\"border: 1px solid black;\">[0]</td>\n\t\t\t<td style=\"border: 1px solid black;\"><code>nums[2] * nums[0] = 4 * 1 = 4</code></td>\n\t\t\t<td style=\"border: 1px solid black;\">4 is a perfect square</td>\n\t\t\t<td style=\"border: 1px solid black;\">1</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p data-end=\"996\" data-start=\"929\">Thus, the total number of valid ancestor pairs across all non-root nodes is 1.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 4, edges = [[0,1],[0,2],[1,3]], nums = [1,2,9,4]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<table style=\"border: 1px solid black;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th style=\"border: 1px solid black;\"><code>i</code></th>\n\t\t\t<th style=\"border: 1px solid black;\"><strong>Ancestors</strong></th>\n\t\t\t<th style=\"border: 1px solid black;\"><code><strong>nums[i] * nums[ancestor]</strong></code></th>\n\t\t\t<th style=\"border: 1px solid black;\">Square Check</th>\n\t\t\t<th style=\"border: 1px solid black;\"><code><strong>t<sub>i</sub></strong></code></th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"border: 1px solid black;\">1</td>\n\t\t\t<td style=\"border: 1px solid black;\">[0]</td>\n\t\t\t<td style=\"border: 1px solid black;\"><code>nums[1] * nums[0] = 2 * 1 = 2</code></td>\n\t\t\t<td style=\"border: 1px solid black;\">2 is <strong>not</strong> a perfect square</td>\n\t\t\t<td style=\"border: 1px solid black;\">0</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 1px solid black;\">2</td>\n\t\t\t<td style=\"border: 1px solid black;\">[0]</td>\n\t\t\t<td style=\"border: 1px solid black;\"><code>nums[2] * nums[0] = 9 * 1 = 9</code></td>\n\t\t\t<td style=\"border: 1px solid black;\">9 is a perfect square</td>\n\t\t\t<td style=\"border: 1px solid black;\">1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 1px solid black;\">3</td>\n\t\t\t<td style=\"border: 1px solid black;\">[1, 0]</td>\n\t\t\t<td style=\"border: 1px solid black;\"><code>nums[3] * nums[1] = 4 * 2 = 8</code><br />\n\t\t\t<code>nums[3] * nums[0] = 4 * 1 = 4</code></td>\n\t\t\t<td style=\"border: 1px solid black;\">Only 4 is a perfect square</td>\n\t\t\t<td style=\"border: 1px solid black;\">1</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>Thus, the total number of valid ancestor pairs across all non-root nodes is <code>0 + 1 + 1 = 2</code>.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li>The input is generated such that <code>edges</code> represents a valid tree.</li>\n</ul>\n",
  "content_markdown": "You are given an integer `n` and an undirected tree rooted at node 0 with `n` nodes numbered from 0 to `n - 1`. This is represented by a 2D array `edges` of length `n - 1`, where `edges[i] = [ui, vi]` indicates an undirected edge between nodes `ui` and `vi`.\n\nYou are also given an integer array `nums`, where `nums[i]` is the positive integer assigned to node `i`.\n\nDefine a value `ti` as the number of **ancestors** of node `i` such that the product `nums[i] * nums[ancestor]` is a **perfect square**.\n\nReturn the sum of all `ti` values for all nodes `i` in range `[1, n - 1]`.\n\n**Note** :\n\n  * In a rooted tree, the **ancestors** of node `i` are all nodes on the path from node `i` to the root node 0, **excluding** `i` itself.\n\n\n\n \n\n**Example 1:**\n\n**Input:** n = 3, edges = [[0,1],[1,2]], nums = [2,8,2]\n\n**Output:** 3\n\n**Explanation:**\n\n`**i**` | **Ancestors** | `**nums[i] * nums[ancestor]**` | Square Check | `**t i**`  \n---|---|---|---|---  \n1 | [0] | `nums[1] * nums[0] = 8 * 2 = 16` | 16 is a perfect square | 1  \n2 | [1, 0] | `nums[2] * nums[1] = 2 * 8 = 16`  \n`nums[2] * nums[0] = 2 * 2 = 4` | Both 4 and 16 are perfect squares | 2  \n  \nThus, the total number of valid ancestor pairs across all non-root nodes is `1 + 2 = 3`.\n\n**Example 2:**\n\n**Input:** n = 3, edges = [[0,1],[0,2]], nums = [1,2,4]\n\n**Output:** 1\n\n**Explanation:**\n\n`**i**` | **Ancestors** | `**nums[i] * nums[ancestor]**` | Square Check | `**t i**`  \n---|---|---|---|---  \n1 | [0] | `nums[1] * nums[0] = 2 * 1 = 2` | 2 is **not** a perfect square | 0  \n2 | [0] | `nums[2] * nums[0] = 4 * 1 = 4` | 4 is a perfect square | 1  \n  \nThus, the total number of valid ancestor pairs across all non-root nodes is 1.\n\n**Example 3:**\n\n**Input:** n = 4, edges = [[0,1],[0,2],[1,3]], nums = [1,2,9,4]\n\n**Output:** 2\n\n**Explanation:**\n\n`i` | **Ancestors** | `**nums[i] * nums[ancestor]**` | Square Check | `**t i**`  \n---|---|---|---|---  \n1 | [0] | `nums[1] * nums[0] = 2 * 1 = 2` | 2 is **not** a perfect square | 0  \n2 | [0] | `nums[2] * nums[0] = 9 * 1 = 9` | 9 is a perfect square | 1  \n3 | [1, 0] | `nums[3] * nums[1] = 4 * 2 = 8`  \n`nums[3] * nums[0] = 4 * 1 = 4` | Only 4 is a perfect square | 1  \n  \nThus, the total number of valid ancestor pairs across all non-root nodes is `0 + 1 + 1 = 2`.\n\n \n\n**Constraints:**\n\n  * `1 <= n <= 105`\n  * `edges.length == n - 1`\n  * `edges[i] = [ui, vi]`\n  * `0 <= ui, vi <= n - 1`\n  * `nums.length == n`\n  * `1 <= nums[i] <= 105`\n  * The input is generated such that `edges` represents a valid tree.",
  "question": "You are given an integer `n` and an undirected tree rooted at node 0 with `n` nodes numbered from 0 to `n - 1`. This is represented by a 2D array `edges` of length `n - 1`, where `edges[i] = [ui, vi]` indicates an undirected edge between nodes `ui` and `vi`.\n\nYou are also given an integer array `nums`, where `nums[i]` is the positive integer assigned to node `i`.\n\nDefine a value `ti` as the number of **ancestors** of node `i` such that the product `nums[i] * nums[ancestor]` is a **perfect square**.\n\nReturn the sum of all `ti` values for all nodes `i` in range `[1, n - 1]`.\n\n**Note** :\n\n  * In a rooted tree, the **ancestors** of node `i` are all nodes on the path from node `i` to the root node 0, **excluding** `i` itself.",
  "examples": "**Example 1:**\n\n**Input:** n = 3, edges = [[0,1],[1,2]], nums = [2,8,2]\n\n**Output:** 3\n\n**Explanation:**\n\n`**i**` | **Ancestors** | `**nums[i] * nums[ancestor]**` | Square Check | `**t i**`  \n---|---|---|---|---  \n1 | [0] | `nums[1] * nums[0] = 8 * 2 = 16` | 16 is a perfect square | 1  \n2 | [1, 0] | `nums[2] * nums[1] = 2 * 8 = 16`  \n`nums[2] * nums[0] = 2 * 2 = 4` | Both 4 and 16 are perfect squares | 2  \n  \nThus, the total number of valid ancestor pairs across all non-root nodes is `1 + 2 = 3`.\n\n**Example 2:**\n\n**Input:** n = 3, edges = [[0,1],[0,2]], nums = [1,2,4]\n\n**Output:** 1\n\n**Explanation:**\n\n`**i**` | **Ancestors** | `**nums[i] * nums[ancestor]**` | Square Check | `**t i**`  \n---|---|---|---|---  \n1 | [0] | `nums[1] * nums[0] = 2 * 1 = 2` | 2 is **not** a perfect square | 0  \n2 | [0] | `nums[2] * nums[0] = 4 * 1 = 4` | 4 is a perfect square | 1  \n  \nThus, the total number of valid ancestor pairs across all non-root nodes is 1.\n\n**Example 3:**\n\n**Input:** n = 4, edges = [[0,1],[0,2],[1,3]], nums = [1,2,9,4]\n\n**Output:** 2\n\n**Explanation:**\n\n`i` | **Ancestors** | `**nums[i] * nums[ancestor]**` | Square Check | `**t i**`  \n---|---|---|---|---  \n1 | [0] | `nums[1] * nums[0] = 2 * 1 = 2` | 2 is **not** a perfect square | 0  \n2 | [0] | `nums[2] * nums[0] = 9 * 1 = 9` | 9 is a perfect square | 1  \n3 | [1, 0] | `nums[3] * nums[1] = 4 * 2 = 8`  \n`nums[3] * nums[0] = 4 * 1 = 4` | Only 4 is a perfect square | 1  \n  \nThus, the total number of valid ancestor pairs across all non-root nodes is `0 + 1 + 1 = 2`.",
  "constraints": "**Constraints:**\n\n  * `1 <= n <= 105`\n  * `edges.length == n - 1`\n  * `edges[i] = [ui, vi]`\n  * `0 <= ui, vi <= n - 1`\n  * `nums.length == n`\n  * `1 <= nums[i] <= 105`\n  * The input is generated such that `edges` represents a valid tree.",
  "topics": [
    "Array",
    "Hash Table",
    "Math",
    "Tree",
    "Depth-First Search",
    "Counting",
    "Number Theory"
  ],
  "total_accepted": 7021,
  "total_submissions": 16517,
  "acceptance_rate": "42.5%",
  "similar_questions": [],
  "hints": [
    "Notice that the product <code>nums[i] * nums[ancestor]</code> is a perfect square if and only if both numbers have the same \"square-free kernel\" (i.e., after removing all even powers of primes, the remaining product is identical).",
    "Precompute the square-free representation of every node's value using prime factorization up to <code>max(nums[i])</code>.",
    "Perform a DFS from the root. While traversing down the tree, maintain a frequency map of the square-free values of the ancestors.",
    "For each node, the number of valid ancestors equals the count of ancestors with the same square-free value.",
    "Carefully backtrack the frequency map after finishing a subtree to maintain correctness."
  ]
}
