{
  "id": "133",
  "title": "Clone Graph",
  "slug": "clone-graph",
  "difficulty": "Medium",
  "category": "Algorithms",
  "content_html": "<p>Given a reference of a node in a <strong><a href=\"https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph\" target=\"_blank\">connected</a></strong> undirected graph.</p>\n\n<p>Return a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\"><strong>deep copy</strong></a> (clone) of the graph.</p>\n\n<p>Each node in the graph contains a value (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p>\n\n<pre>\nclass Node {\n    public int val;\n    public List&lt;Node&gt; neighbors;\n}\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Test case format:</strong></p>\n\n<p>For simplicity, each node&#39;s value is the same as the node&#39;s index (1-indexed). For example, the first node with <code>val == 1</code>, the second node with <code>val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p>\n\n<p><b>An adjacency list</b> is a collection of unordered <b>lists</b> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p>\n\n<p>The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png\" style=\"width: 454px; height: 500px;\" />\n<pre>\n<strong>Input:</strong> adjList = [[2,4],[1,3],[2,4],[1,3]]\n<strong>Output:</strong> [[2,4],[1,3],[2,4],[1,3]]\n<strong>Explanation:</strong> There are 4 nodes in the graph.\n1st node (val = 1)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/07/graph.png\" style=\"width: 163px; height: 148px;\" />\n<pre>\n<strong>Input:</strong> adjList = [[]]\n<strong>Output:</strong> [[]]\n<strong>Explanation:</strong> Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> adjList = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> This an empty graph, it does not have any nodes.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the graph is in the range <code>[0, 100]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>Node.val</code> is unique for each node.</li>\n\t<li>There are no repeated edges and no self-loops in the graph.</li>\n\t<li>The Graph is connected and all nodes can be visited starting from the given node.</li>\n</ul>\n",
  "content_markdown": "Given a reference of a node in a **[connected](<https://en.wikipedia.org/wiki/Connectivity_\\(graph_theory\\)#Connected_graph>)** undirected graph.\n\nReturn a [**deep copy**](<https://en.wikipedia.org/wiki/Object_copying#Deep_copy>) (clone) of the graph.\n\nEach node in the graph contains a value (`int`) and a list (`List[Node]`) of its neighbors.\n    \n    \n    class Node {\n        public int val;\n        public List<Node> neighbors;\n    }\n    \n\n \n\n**Test case format:**\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with `val == 1`, the second node with `val == 2`, and so on. The graph is represented in the test case using an adjacency list.\n\n**An adjacency list** is a collection of unordered **lists** used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\nThe given node will always be the first node with `val = 1`. You must return the **copy of the given node** as a reference to the cloned graph.\n\n \n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png)\n    \n    \n    **Input:** adjList = [[2,4],[1,3],[2,4],[1,3]]\n    **Output:** [[2,4],[1,3],[2,4],[1,3]]\n    **Explanation:** There are 4 nodes in the graph.\n    1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n    2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n    3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n    4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/01/07/graph.png)\n    \n    \n    **Input:** adjList = [[]]\n    **Output:** [[]]\n    **Explanation:** Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n    \n\n**Example 3:**\n    \n    \n    **Input:** adjList = []\n    **Output:** []\n    **Explanation:** This an empty graph, it does not have any nodes.\n    \n\n \n\n**Constraints:**\n\n  * The number of nodes in the graph is in the range `[0, 100]`.\n  * `1 <= Node.val <= 100`\n  * `Node.val` is unique for each node.\n  * There are no repeated edges and no self-loops in the graph.\n  * The Graph is connected and all nodes can be visited starting from the given node.",
  "question": "Given a reference of a node in a **[connected](<https://en.wikipedia.org/wiki/Connectivity_\\(graph_theory\\)#Connected_graph>)** undirected graph.\n\nReturn a [**deep copy**](<https://en.wikipedia.org/wiki/Object_copying#Deep_copy>) (clone) of the graph.\n\nEach node in the graph contains a value (`int`) and a list (`List[Node]`) of its neighbors.\n    \n    \n    class Node {\n        public int val;\n        public List<Node> neighbors;\n    }\n    \n\n \n\n**Test case format:**\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with `val == 1`, the second node with `val == 2`, and so on. The graph is represented in the test case using an adjacency list.\n\n**An adjacency list** is a collection of unordered **lists** used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\nThe given node will always be the first node with `val = 1`. You must return the **copy of the given node** as a reference to the cloned graph.",
  "examples": "**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png)\n    \n    \n    **Input:** adjList = [[2,4],[1,3],[2,4],[1,3]]\n    **Output:** [[2,4],[1,3],[2,4],[1,3]]\n    **Explanation:** There are 4 nodes in the graph.\n    1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n    2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n    3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n    4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/01/07/graph.png)\n    \n    \n    **Input:** adjList = [[]]\n    **Output:** [[]]\n    **Explanation:** Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n    \n\n**Example 3:**\n    \n    \n    **Input:** adjList = []\n    **Output:** []\n    **Explanation:** This an empty graph, it does not have any nodes.",
  "constraints": "**Constraints:**\n\n  * The number of nodes in the graph is in the range `[0, 100]`.\n  * `1 <= Node.val <= 100`\n  * `Node.val` is unique for each node.\n  * There are no repeated edges and no self-loops in the graph.\n  * The Graph is connected and all nodes can be visited starting from the given node.",
  "topics": ["Hash Table", "Depth-First Search", "Breadth-First Search", "Graph Theory"],
  "total_accepted": 1845997,
  "total_submissions": 2851820,
  "acceptance_rate": "64.7%",
  "similar_questions": [
    {
      "title": "Copy List with Random Pointer",
      "slug": "copy-list-with-random-pointer",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/copy-list-with-random-pointer/"
    },
    {
      "title": "Clone Binary Tree With Random Pointer",
      "slug": "clone-binary-tree-with-random-pointer",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/clone-binary-tree-with-random-pointer/"
    },
    {
      "title": "Clone N-ary Tree",
      "slug": "clone-n-ary-tree",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/clone-n-ary-tree/"
    }
  ],
  "hints": []
}
