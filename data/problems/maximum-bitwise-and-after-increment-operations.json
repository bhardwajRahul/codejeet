{
  "id": "3806",
  "title": "Maximum Bitwise AND After Increment Operations",
  "slug": "maximum-bitwise-and-after-increment-operations",
  "difficulty": "Hard",
  "category": "Algorithms",
  "content_html": "<p>You are given an integer array <code>nums</code> and two integers <code>k</code> and <code>m</code>.</p>\n\n<p>You may perform <strong>at most</strong> <code>k</code> operations. In one operation, you may choose any index <code>i</code> and <strong>increase</strong> <code>nums[i]</code> by 1.</p>\n\n<p>Return an integer denoting the <strong>maximum</strong> possible <strong>bitwise AND</strong> of any <strong><span data-keyword=\"subset\">subset</span></strong> of size <code>m</code> after performing up to <code>k</code> operations optimally.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [3,1,2], k = 8, m = 2</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">6</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li>We need a subset of size <code>m = 2</code>. Choose indices <code>[0, 2]</code>.</li>\n\t<li>Increase <code>nums[0] = 3</code> to 6 using 3 operations, and increase <code>nums[2] = 2</code> to 6 using 4 operations.</li>\n\t<li>The total number of operations used is 7, which is not greater than <code>k = 8</code>.</li>\n\t<li>The two chosen values become <code>[6, 6]</code>, and their bitwise AND is <code>6</code>, which is the maximum possible.</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [1,2,8,4], k = 7, m = 3</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">4</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li>We need a subset of size <code>m = 3</code>. Choose indices <code>[0, 1, 3]</code>.</li>\n\t<li>Increase <code>nums[0] = 1</code> to 4 using 3 operations, increase <code>nums[1] = 2</code> to 4 using 2 operations, and keep <code>nums[3] = 4</code>.</li>\n\t<li>The total number of operations used is 5, which is not greater than <code>k = 7</code>.</li>\n\t<li>The three chosen values become <code>[4, 4, 4]</code>, and their bitwise AND is 4, which is the maximum possible.​​​​​​​</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [1,1], k = 3, m = 2</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li>We need a subset of size <code>m = 2</code>. Choose indices <code>[0, 1]</code>.</li>\n\t<li>Increase both values from 1 to 2 using 1 operation each.</li>\n\t<li>The total number of operations used is 2, which is not greater than <code>k = 3</code>.</li>\n\t<li>The two chosen values become <code>[2, 2]</code>, and their bitwise AND is 2, which is the maximum possible.</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= m &lt;= n</code></li>\n</ul>\n",
  "content_markdown": "You are given an integer array `nums` and two integers `k` and `m`.\n\nYou may perform **at most** `k` operations. In one operation, you may choose any index `i` and **increase** `nums[i]` by 1.\n\nReturn an integer denoting the **maximum** possible **bitwise AND** of any **subset** of size `m` after performing up to `k` operations optimally.\n\n \n\n**Example 1:**\n\n**Input:** nums = [3,1,2], k = 8, m = 2\n\n**Output:** 6\n\n**Explanation:**\n\n  * We need a subset of size `m = 2`. Choose indices `[0, 2]`.\n  * Increase `nums[0] = 3` to 6 using 3 operations, and increase `nums[2] = 2` to 6 using 4 operations.\n  * The total number of operations used is 7, which is not greater than `k = 8`.\n  * The two chosen values become `[6, 6]`, and their bitwise AND is `6`, which is the maximum possible.\n\n\n\n**Example 2:**\n\n**Input:** nums = [1,2,8,4], k = 7, m = 3\n\n**Output:** 4\n\n**Explanation:**\n\n  * We need a subset of size `m = 3`. Choose indices `[0, 1, 3]`.\n  * Increase `nums[0] = 1` to 4 using 3 operations, increase `nums[1] = 2` to 4 using 2 operations, and keep `nums[3] = 4`.\n  * The total number of operations used is 5, which is not greater than `k = 7`.\n  * The three chosen values become `[4, 4, 4]`, and their bitwise AND is 4, which is the maximum possible.​​​​​​​\n\n\n\n**Example 3:**\n\n**Input:** nums = [1,1], k = 3, m = 2\n\n**Output:** 2\n\n**Explanation:**\n\n  * We need a subset of size `m = 2`. Choose indices `[0, 1]`.\n  * Increase both values from 1 to 2 using 1 operation each.\n  * The total number of operations used is 2, which is not greater than `k = 3`.\n  * The two chosen values become `[2, 2]`, and their bitwise AND is 2, which is the maximum possible.\n\n\n\n \n\n**Constraints:**\n\n  * `1 <= n == nums.length <= 5 * 104`\n  * `1 <= nums[i] <= 109`\n  * `1 <= k <= 109`\n  * `1 <= m <= n`",
  "question": "You are given an integer array `nums` and two integers `k` and `m`.\n\nYou may perform **at most** `k` operations. In one operation, you may choose any index `i` and **increase** `nums[i]` by 1.\n\nReturn an integer denoting the **maximum** possible **bitwise AND** of any **subset** of size `m` after performing up to `k` operations optimally.",
  "examples": "**Example 1:**\n\n**Input:** nums = [3,1,2], k = 8, m = 2\n\n**Output:** 6\n\n**Explanation:**\n\n  * We need a subset of size `m = 2`. Choose indices `[0, 2]`.\n  * Increase `nums[0] = 3` to 6 using 3 operations, and increase `nums[2] = 2` to 6 using 4 operations.\n  * The total number of operations used is 7, which is not greater than `k = 8`.\n  * The two chosen values become `[6, 6]`, and their bitwise AND is `6`, which is the maximum possible.\n\n\n\n**Example 2:**\n\n**Input:** nums = [1,2,8,4], k = 7, m = 3\n\n**Output:** 4\n\n**Explanation:**\n\n  * We need a subset of size `m = 3`. Choose indices `[0, 1, 3]`.\n  * Increase `nums[0] = 1` to 4 using 3 operations, increase `nums[1] = 2` to 4 using 2 operations, and keep `nums[3] = 4`.\n  * The total number of operations used is 5, which is not greater than `k = 7`.\n  * The three chosen values become `[4, 4, 4]`, and their bitwise AND is 4, which is the maximum possible.​​​​​​​\n\n\n\n**Example 3:**\n\n**Input:** nums = [1,1], k = 3, m = 2\n\n**Output:** 2\n\n**Explanation:**\n\n  * We need a subset of size `m = 2`. Choose indices `[0, 1]`.\n  * Increase both values from 1 to 2 using 1 operation each.\n  * The total number of operations used is 2, which is not greater than `k = 3`.\n  * The two chosen values become `[2, 2]`, and their bitwise AND is 2, which is the maximum possible.",
  "constraints": "**Constraints:**\n\n  * `1 <= n == nums.length <= 5 * 104`\n  * `1 <= nums[i] <= 109`\n  * `1 <= k <= 109`\n  * `1 <= m <= n`",
  "topics": ["Array", "Greedy", "Bit Manipulation", "Sorting"],
  "total_accepted": 6397,
  "total_submissions": 20652,
  "acceptance_rate": "31.0%",
  "similar_questions": [],
  "hints": [
    "Use a greedy bitwise approach.",
    "Iterate bits from highest to lowest and try setting the current bit in a candidate <code>res</code>.",
    "To test a candidate, for each <code>num</code> compute the minimal increments needed so that <code>(num | candidate) == candidate</code>; take the smallest <code>m</code> costs and check if their sum <= <code>k</code>.",
    "If feasible, keep the bit in <code>res</code> and continue with accumulated bits."
  ]
}
