{
  "id": "2623",
  "title": "Memoize",
  "slug": "memoize",
  "difficulty": "Medium",
  "category": "JavaScript",
  "content_html": "<p>Given a function <code>fn</code>, return a&nbsp;<strong>memoized</strong>&nbsp;version of that function.</p>\n\n<p>A&nbsp;<strong>memoized&nbsp;</strong>function is a function that will never be called twice with&nbsp;the same inputs. Instead it will return&nbsp;a cached value.</p>\n\n<p>You can assume there are&nbsp;<strong>3&nbsp;</strong>possible input functions:&nbsp;<code>sum</code><strong>, </strong><code>fib</code><strong>,&nbsp;</strong>and&nbsp;<code>factorial</code><strong>.</strong></p>\n\n<ul>\n\t<li><code>sum</code><strong>&nbsp;</strong>accepts two integers&nbsp;<code>a</code> and <code>b</code> and returns <code>a + b</code>.&nbsp;Assume that if a value has already been cached for the arguments <code>(b, a)</code> where <code>a != b</code>, it cannot be used for the arguments <code>(a, b)</code>. For example, if the arguments are <code>(3, 2)</code> and <code>(2, 3)</code>, two separate calls should be made.</li>\n\t<li><code>fib</code><strong>&nbsp;</strong>accepts a&nbsp;single integer&nbsp;<code>n</code> and&nbsp;returns&nbsp;<code>1</code> if <font face=\"monospace\"><code>n &lt;= 1</code> </font>or<font face=\"monospace\">&nbsp;<code>fib(n - 1) + fib(n - 2)</code>&nbsp;</font>otherwise.</li>\n\t<li><code>factorial</code>&nbsp;accepts a single integer&nbsp;<code>n</code> and returns <code>1</code>&nbsp;if&nbsp;<code>n &lt;= 1</code>&nbsp;or&nbsp;<code>factorial(n - 1) * n</code>&nbsp;otherwise.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong>\nfnName = &quot;sum&quot;\nactions = [&quot;call&quot;,&quot;call&quot;,&quot;getCallCount&quot;,&quot;call&quot;,&quot;getCallCount&quot;]\nvalues = [[2,2],[2,2],[],[1,2],[]]\n<strong>Output:</strong> [4,4,1,3,2]\n<strong>Explanation:</strong>\nconst sum = (a, b) =&gt; a + b;\nconst memoizedSum = memoize(sum);\nmemoizedSum(2, 2); // &quot;call&quot; - returns 4. sum() was called as (2, 2) was not seen before.\nmemoizedSum(2, 2); // &quot;call&quot; - returns 4. However sum() was not called because the same inputs were seen before.\n// &quot;getCallCount&quot; - total call count: 1\nmemoizedSum(1, 2); // &quot;call&quot; - returns 3. sum() was called as (1, 2) was not seen before.\n// &quot;getCallCount&quot; - total call count: 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:\n</strong>fnName = &quot;factorial&quot;\nactions = [&quot;call&quot;,&quot;call&quot;,&quot;call&quot;,&quot;getCallCount&quot;,&quot;call&quot;,&quot;getCallCount&quot;]\nvalues = [[2],[3],[2],[],[3],[]]\n<strong>Output:</strong> [2,6,2,2,6,2]\n<strong>Explanation:</strong>\nconst factorial = (n) =&gt; (n &lt;= 1) ? 1 : (n * factorial(n - 1));\nconst memoFactorial = memoize(factorial);\nmemoFactorial(2); // &quot;call&quot; - returns 2.\nmemoFactorial(3); // &quot;call&quot; - returns 6.\nmemoFactorial(2); // &quot;call&quot; - returns 2. However factorial was not called because 2 was seen before.\n// &quot;getCallCount&quot; - total call count: 2\nmemoFactorial(3); // &quot;call&quot; - returns 6. However factorial was not called because 3 was seen before.\n// &quot;getCallCount&quot; - total call count: 2\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:\n</strong>fnName = &quot;fib&quot;\nactions = [&quot;call&quot;,&quot;getCallCount&quot;]\nvalues = [[5],[]]\n<strong>Output:</strong> [8,1]\n<strong>Explanation:\n</strong>fib(5) = 8 // &quot;call&quot;\n// &quot;getCallCount&quot; - total call count: 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= a, b &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>1 &lt;= actions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>actions.length === values.length</code></li>\n\t<li><code>actions[i]</code> is one of &quot;call&quot; and &quot;getCallCount&quot;</li>\n\t<li><code>fnName</code> is one of &quot;sum&quot;, &quot;factorial&quot; and&nbsp;&quot;fib&quot;</li>\n</ul>\n",
  "content_markdown": "Given a function `fn`, return a **memoized**  version of that function.\n\nA **memoized  **function is a function that will never be called twice with the same inputs. Instead it will return a cached value.\n\nYou can assume there are **3  **possible input functions: `sum`**,**`fib`**,  **and `factorial`**.**\n\n  * `sum`** ** accepts two integers `a` and `b` and returns `a + b`. Assume that if a value has already been cached for the arguments `(b, a)` where `a != b`, it cannot be used for the arguments `(a, b)`. For example, if the arguments are `(3, 2)` and `(2, 3)`, two separate calls should be made.\n  * `fib`** ** accepts a single integer `n` and returns `1` if `n <= 1` or `fib(n - 1) + fib(n - 2)` otherwise.\n  * `factorial` accepts a single integer `n` and returns `1` if `n <= 1` or `factorial(n - 1) * n` otherwise.\n\n\n\n \n\n**Example 1:**\n    \n    \n    **Input:**\n    fnName = \"sum\"\n    actions = [\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\n    values = [[2,2],[2,2],[],[1,2],[]]\n    **Output:** [4,4,1,3,2]\n    **Explanation:**\n    const sum = (a, b) => a + b;\n    const memoizedSum = memoize(sum);\n    memoizedSum(2, 2); // \"call\" - returns 4. sum() was called as (2, 2) was not seen before.\n    memoizedSum(2, 2); // \"call\" - returns 4. However sum() was not called because the same inputs were seen before.\n    // \"getCallCount\" - total call count: 1\n    memoizedSum(1, 2); // \"call\" - returns 3. sum() was called as (1, 2) was not seen before.\n    // \"getCallCount\" - total call count: 2\n    \n\n**Example 2:**\n    \n    \n    **Input:** fnName = \"factorial\"\n    actions = [\"call\",\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\n    values = [[2],[3],[2],[],[3],[]]\n    **Output:** [2,6,2,2,6,2]\n    **Explanation:**\n    const factorial = (n) => (n <= 1) ? 1 : (n * factorial(n - 1));\n    const memoFactorial = memoize(factorial);\n    memoFactorial(2); // \"call\" - returns 2.\n    memoFactorial(3); // \"call\" - returns 6.\n    memoFactorial(2); // \"call\" - returns 2. However factorial was not called because 2 was seen before.\n    // \"getCallCount\" - total call count: 2\n    memoFactorial(3); // \"call\" - returns 6. However factorial was not called because 3 was seen before.\n    // \"getCallCount\" - total call count: 2\n    \n\n**Example 3:**\n    \n    \n    **Input:** fnName = \"fib\"\n    actions = [\"call\",\"getCallCount\"]\n    values = [[5],[]]\n    **Output:** [8,1]\n    **Explanation:** fib(5) = 8 // \"call\"\n    // \"getCallCount\" - total call count: 1\n    \n\n \n\n**Constraints:**\n\n  * `0 <= a, b <= 105`\n  * `1 <= n <= 10`\n  * `1 <= actions.length <= 105`\n  * `actions.length === values.length`\n  * `actions[i]` is one of \"call\" and \"getCallCount\"\n  * `fnName` is one of \"sum\", \"factorial\" and \"fib\"",
  "question": "Given a function `fn`, return a **memoized**  version of that function.\n\nA **memoized  **function is a function that will never be called twice with the same inputs. Instead it will return a cached value.\n\nYou can assume there are **3  **possible input functions: `sum`**,**`fib`**,  **and `factorial`**.**\n\n  * `sum`** ** accepts two integers `a` and `b` and returns `a + b`. Assume that if a value has already been cached for the arguments `(b, a)` where `a != b`, it cannot be used for the arguments `(a, b)`. For example, if the arguments are `(3, 2)` and `(2, 3)`, two separate calls should be made.\n  * `fib`** ** accepts a single integer `n` and returns `1` if `n <= 1` or `fib(n - 1) + fib(n - 2)` otherwise.\n  * `factorial` accepts a single integer `n` and returns `1` if `n <= 1` or `factorial(n - 1) * n` otherwise.",
  "examples": "**Example 1:**\n    \n    \n    **Input:**\n    fnName = \"sum\"\n    actions = [\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\n    values = [[2,2],[2,2],[],[1,2],[]]\n    **Output:** [4,4,1,3,2]\n    **Explanation:**\n    const sum = (a, b) => a + b;\n    const memoizedSum = memoize(sum);\n    memoizedSum(2, 2); // \"call\" - returns 4. sum() was called as (2, 2) was not seen before.\n    memoizedSum(2, 2); // \"call\" - returns 4. However sum() was not called because the same inputs were seen before.\n    // \"getCallCount\" - total call count: 1\n    memoizedSum(1, 2); // \"call\" - returns 3. sum() was called as (1, 2) was not seen before.\n    // \"getCallCount\" - total call count: 2\n    \n\n**Example 2:**\n    \n    \n    **Input:** fnName = \"factorial\"\n    actions = [\"call\",\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\n    values = [[2],[3],[2],[],[3],[]]\n    **Output:** [2,6,2,2,6,2]\n    **Explanation:**\n    const factorial = (n) => (n <= 1) ? 1 : (n * factorial(n - 1));\n    const memoFactorial = memoize(factorial);\n    memoFactorial(2); // \"call\" - returns 2.\n    memoFactorial(3); // \"call\" - returns 6.\n    memoFactorial(2); // \"call\" - returns 2. However factorial was not called because 2 was seen before.\n    // \"getCallCount\" - total call count: 2\n    memoFactorial(3); // \"call\" - returns 6. However factorial was not called because 3 was seen before.\n    // \"getCallCount\" - total call count: 2\n    \n\n**Example 3:**\n    \n    \n    **Input:** fnName = \"fib\"\n    actions = [\"call\",\"getCallCount\"]\n    values = [[5],[]]\n    **Output:** [8,1]\n    **Explanation:** fib(5) = 8 // \"call\"\n    // \"getCallCount\" - total call count: 1",
  "constraints": "**Constraints:**\n\n  * `0 <= a, b <= 105`\n  * `1 <= n <= 10`\n  * `1 <= actions.length <= 105`\n  * `actions.length === values.length`\n  * `actions[i]` is one of \"call\" and \"getCallCount\"\n  * `fnName` is one of \"sum\", \"factorial\" and \"fib\"",
  "topics": [],
  "total_accepted": 180425,
  "total_submissions": 278474,
  "acceptance_rate": "64.8%",
  "similar_questions": [
    {
      "title": "Counter",
      "slug": "counter",
      "difficulty": "Easy",
      "url": "https://leetcode.com/problems/counter/"
    },
    {
      "title": "Curry",
      "slug": "curry",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/curry/"
    },
    {
      "title": "Function Composition",
      "slug": "function-composition",
      "difficulty": "Easy",
      "url": "https://leetcode.com/problems/function-composition/"
    },
    {
      "title": "Memoize II",
      "slug": "memoize-ii",
      "difficulty": "Hard",
      "url": "https://leetcode.com/problems/memoize-ii/"
    }
  ],
  "hints": [
    "You can create copy of a function by spreading function parameters. \r\n\r\nfunction outerFunction(passedFunction) {\r\n  return newFunction(...params) {\r\n    return passedFunction(...params);\r\n  };\r\n}",
    "params is an array. Since you know all values in the array are numbers, you can turn it into a string with JSON.stringify().",
    "In the outerFunction, you can declare a Map or Object. In the inner function you can avoid executing the passed function if the params have already been passed before."
  ]
}
