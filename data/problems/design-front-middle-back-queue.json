{
  "id": "1670",
  "title": "Design Front Middle Back Queue",
  "slug": "design-front-middle-back-queue",
  "difficulty": "Medium",
  "category": "Algorithms",
  "content_html": "<p>Design a queue that supports <code>push</code> and <code>pop</code> operations in the front, middle, and back.</p>\n\n<p>Implement the <code>FrontMiddleBack</code> class:</p>\n\n<ul>\n\t<li><code>FrontMiddleBack()</code> Initializes the queue.</li>\n\t<li><code>void pushFront(int val)</code> Adds <code>val</code> to the <strong>front</strong> of the queue.</li>\n\t<li><code>void pushMiddle(int val)</code> Adds <code>val</code> to the <strong>middle</strong> of the queue.</li>\n\t<li><code>void pushBack(int val)</code> Adds <code>val</code> to the <strong>back</strong> of the queue.</li>\n\t<li><code>int popFront()</code> Removes the <strong>front</strong> element of the queue and returns it. If the queue is empty, return <code>-1</code>.</li>\n\t<li><code>int popMiddle()</code> Removes the <strong>middle</strong> element of the queue and returns it. If the queue is empty, return <code>-1</code>.</li>\n\t<li><code>int popBack()</code> Removes the <strong>back</strong> element of the queue and returns it. If the queue is empty, return <code>-1</code>.</li>\n</ul>\n\n<p><strong>Notice</strong> that when there are <b>two</b> middle position choices, the operation is performed on the <strong>frontmost</strong> middle position choice. For example:</p>\n\n<ul>\n\t<li>Pushing <code>6</code> into the middle of <code>[1, 2, 3, 4, 5]</code> results in <code>[1, 2, <u>6</u>, 3, 4, 5]</code>.</li>\n\t<li>Popping the middle from <code>[1, 2, <u>3</u>, 4, 5, 6]</code> returns <code>3</code> and results in <code>[1, 2, 4, 5, 6]</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong>\n[&quot;FrontMiddleBackQueue&quot;, &quot;pushFront&quot;, &quot;pushBack&quot;, &quot;pushMiddle&quot;, &quot;pushMiddle&quot;, &quot;popFront&quot;, &quot;popMiddle&quot;, &quot;popMiddle&quot;, &quot;popBack&quot;, &quot;popFront&quot;]\n[[], [1], [2], [3], [4], [], [], [], [], []]\n<strong>Output:</strong>\n[null, null, null, null, null, 1, 3, 4, 2, -1]\n\n<strong>Explanation:</strong>\nFrontMiddleBackQueue q = new FrontMiddleBackQueue();\nq.pushFront(1);   // [<u>1</u>]\nq.pushBack(2);    // [1, <u>2</u>]\nq.pushMiddle(3);  // [1, <u>3</u>, 2]\nq.pushMiddle(4);  // [1, <u>4</u>, 3, 2]\nq.popFront();     // return 1 -&gt; [4, 3, 2]\nq.popMiddle();    // return 3 -&gt; [4, 2]\nq.popMiddle();    // return 4 -&gt; [2]\nq.popBack();      // return 2 -&gt; []\nq.popFront();     // return -1 -&gt; [] (The queue is empty)\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= val &lt;= 10<sup>9</sup></code></li>\n\t<li>At most&nbsp;<code>1000</code>&nbsp;calls will be made to&nbsp;<code>pushFront</code>,&nbsp;<code>pushMiddle</code>,&nbsp;<code>pushBack</code>, <code>popFront</code>, <code>popMiddle</code>, and <code>popBack</code>.</li>\n</ul>\n",
  "content_markdown": "Design a queue that supports `push` and `pop` operations in the front, middle, and back.\n\nImplement the `FrontMiddleBack` class:\n\n  * `FrontMiddleBack()` Initializes the queue.\n  * `void pushFront(int val)` Adds `val` to the **front** of the queue.\n  * `void pushMiddle(int val)` Adds `val` to the **middle** of the queue.\n  * `void pushBack(int val)` Adds `val` to the **back** of the queue.\n  * `int popFront()` Removes the **front** element of the queue and returns it. If the queue is empty, return `-1`.\n  * `int popMiddle()` Removes the **middle** element of the queue and returns it. If the queue is empty, return `-1`.\n  * `int popBack()` Removes the **back** element of the queue and returns it. If the queue is empty, return `-1`.\n\n\n\n**Notice** that when there are **two** middle position choices, the operation is performed on the **frontmost** middle position choice. For example:\n\n  * Pushing `6` into the middle of `[1, 2, 3, 4, 5]` results in `[1, 2, _6_ , 3, 4, 5]`.\n  * Popping the middle from `[1, 2, _3_ , 4, 5, 6]` returns `3` and results in `[1, 2, 4, 5, 6]`.\n\n\n\n \n\n**Example 1:**\n    \n    \n    **Input:**\n    [\"FrontMiddleBackQueue\", \"pushFront\", \"pushBack\", \"pushMiddle\", \"pushMiddle\", \"popFront\", \"popMiddle\", \"popMiddle\", \"popBack\", \"popFront\"]\n    [[], [1], [2], [3], [4], [], [], [], [], []]\n    **Output:**\n    [null, null, null, null, null, 1, 3, 4, 2, -1]\n    \n    **Explanation:**\n    FrontMiddleBackQueue q = new FrontMiddleBackQueue();\n    q.pushFront(1);   // [_1_]\n    q.pushBack(2);    // [1, _2_]\n    q.pushMiddle(3);  // [1, _3_ , 2]\n    q.pushMiddle(4);  // [1, _4_ , 3, 2]\n    q.popFront();     // return 1 -> [4, 3, 2]\n    q.popMiddle();    // return 3 -> [4, 2]\n    q.popMiddle();    // return 4 -> [2]\n    q.popBack();      // return 2 -> []\n    q.popFront();     // return -1 -> [] (The queue is empty)\n    \n\n \n\n**Constraints:**\n\n  * `1 <= val <= 109`\n  * At most `1000` calls will be made to `pushFront`, `pushMiddle`, `pushBack`, `popFront`, `popMiddle`, and `popBack`.",
  "question": "Design a queue that supports `push` and `pop` operations in the front, middle, and back.\n\nImplement the `FrontMiddleBack` class:\n\n  * `FrontMiddleBack()` Initializes the queue.\n  * `void pushFront(int val)` Adds `val` to the **front** of the queue.\n  * `void pushMiddle(int val)` Adds `val` to the **middle** of the queue.\n  * `void pushBack(int val)` Adds `val` to the **back** of the queue.\n  * `int popFront()` Removes the **front** element of the queue and returns it. If the queue is empty, return `-1`.\n  * `int popMiddle()` Removes the **middle** element of the queue and returns it. If the queue is empty, return `-1`.\n  * `int popBack()` Removes the **back** element of the queue and returns it. If the queue is empty, return `-1`.\n\n\n\n**Notice** that when there are **two** middle position choices, the operation is performed on the **frontmost** middle position choice. For example:\n\n  * Pushing `6` into the middle of `[1, 2, 3, 4, 5]` results in `[1, 2, _6_ , 3, 4, 5]`.\n  * Popping the middle from `[1, 2, _3_ , 4, 5, 6]` returns `3` and results in `[1, 2, 4, 5, 6]`.",
  "examples": "**Example 1:**\n    \n    \n    **Input:**\n    [\"FrontMiddleBackQueue\", \"pushFront\", \"pushBack\", \"pushMiddle\", \"pushMiddle\", \"popFront\", \"popMiddle\", \"popMiddle\", \"popBack\", \"popFront\"]\n    [[], [1], [2], [3], [4], [], [], [], [], []]\n    **Output:**\n    [null, null, null, null, null, 1, 3, 4, 2, -1]\n    \n    **Explanation:**\n    FrontMiddleBackQueue q = new FrontMiddleBackQueue();\n    q.pushFront(1);   // [_1_]\n    q.pushBack(2);    // [1, _2_]\n    q.pushMiddle(3);  // [1, _3_ , 2]\n    q.pushMiddle(4);  // [1, _4_ , 3, 2]\n    q.popFront();     // return 1 -> [4, 3, 2]\n    q.popMiddle();    // return 3 -> [4, 2]\n    q.popMiddle();    // return 4 -> [2]\n    q.popBack();      // return 2 -> []\n    q.popFront();     // return -1 -> [] (The queue is empty)",
  "constraints": "**Constraints:**\n\n  * `1 <= val <= 109`\n  * At most `1000` calls will be made to `pushFront`, `pushMiddle`, `pushBack`, `popFront`, `popMiddle`, and `popBack`.",
  "topics": ["Array", "Linked List", "Design", "Queue", "Doubly-Linked List", "Data Stream"],
  "total_accepted": 42291,
  "total_submissions": 74292,
  "acceptance_rate": "56.9%",
  "similar_questions": [
    {
      "title": "Design Circular Deque",
      "slug": "design-circular-deque",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/design-circular-deque/"
    },
    {
      "title": "Design Circular Queue",
      "slug": "design-circular-queue",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/design-circular-queue/"
    }
  ],
  "hints": [
    "The constraints are low enough for a brute force, single array approach.",
    "For an O(1) per method approach, use 2 double-ended queues: one for the first half and one for the second half."
  ]
}
