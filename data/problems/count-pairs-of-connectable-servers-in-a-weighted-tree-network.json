{
  "id": "3067",
  "title": "Count Pairs of Connectable Servers in a Weighted Tree Network",
  "slug": "count-pairs-of-connectable-servers-in-a-weighted-tree-network",
  "difficulty": "Medium",
  "category": "Algorithms",
  "content_html": "<p>You are given an unrooted weighted tree with <code>n</code> vertices representing servers numbered from <code>0</code> to <code>n - 1</code>, an array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, weight<sub>i</sub>]</code> represents a bidirectional edge between vertices <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> of weight <code>weight<sub>i</sub></code>. You are also given an integer <code>signalSpeed</code>.</p>\n\n<p>Two servers <code>a</code> and <code>b</code> are <strong>connectable</strong> through a server <code>c</code> if:</p>\n\n<ul>\n\t<li><code>a &lt; b</code>, <code>a != c</code> and <code>b != c</code>.</li>\n\t<li>The distance from <code>c</code> to <code>a</code> is divisible by <code>signalSpeed</code>.</li>\n\t<li>The distance from <code>c</code> to <code>b</code> is divisible by <code>signalSpeed</code>.</li>\n\t<li>The path from <code>c</code> to <code>b</code> and the path from <code>c</code> to <code>a</code> do not share any edges.</li>\n</ul>\n\n<p>Return <em>an integer array</em> <code>count</code> <em>of length</em> <code>n</code> <em>where</em> <code>count[i]</code> <em>is the <strong>number</strong> of server pairs that are <strong>connectable</strong> through</em> <em>the server</em> <code>i</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/21/example22.png\" style=\"width: 438px; height: 243px; padding: 10px; background: #fff; border-radius: .5rem;\" />\n<pre>\n<strong>Input:</strong> edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1\n<strong>Output:</strong> [0,4,6,6,4,0]\n<strong>Explanation:</strong> Since signalSpeed is 1, count[c] is equal to the number of pairs of paths that start at c and do not share any edges.\nIn the case of the given path graph, count[c] is equal to the number of servers to the left of c multiplied by the servers to the right of c.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/21/example11.png\" style=\"width: 495px; height: 484px; padding: 10px; background: #fff; border-radius: .5rem;\" />\n<pre>\n<strong>Input:</strong> edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3\n<strong>Output:</strong> [2,0,0,0,0,0,2]\n<strong>Explanation:</strong> Through server 0, there are 2 pairs of connectable servers: (4, 5) and (4, 6).\nThrough server 6, there are 2 pairs of connectable servers: (4, 5) and (0, 5).\nIt can be shown that no two servers are connectable through servers other than 0 and 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, weight<sub>i</sub>]</code><!-- notionvc: a2623897-1bb1-4c07-84b6-917ffdcd83ec --></li>\n\t<li><code>1 &lt;= weight<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= signalSpeed &lt;= 10<sup>6</sup></code></li>\n\t<li>The input is generated such that <code>edges</code> represents a valid tree.</li>\n</ul>\n",
  "content_markdown": "You are given an unrooted weighted tree with `n` vertices representing servers numbered from `0` to `n - 1`, an array `edges` where `edges[i] = [ai, bi, weighti]` represents a bidirectional edge between vertices `ai` and `bi` of weight `weighti`. You are also given an integer `signalSpeed`.\n\nTwo servers `a` and `b` are **connectable** through a server `c` if:\n\n  * `a < b`, `a != c` and `b != c`.\n  * The distance from `c` to `a` is divisible by `signalSpeed`.\n  * The distance from `c` to `b` is divisible by `signalSpeed`.\n  * The path from `c` to `b` and the path from `c` to `a` do not share any edges.\n\n\n\nReturn _an integer array_ `count` _of length_ `n` _where_ `count[i]` _is the**number** of server pairs that are **connectable** through_ _the server_ `i`.\n\n \n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2024/01/21/example22.png)\n    \n    \n    **Input:** edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1\n    **Output:** [0,4,6,6,4,0]\n    **Explanation:** Since signalSpeed is 1, count[c] is equal to the number of pairs of paths that start at c and do not share any edges.\n    In the case of the given path graph, count[c] is equal to the number of servers to the left of c multiplied by the servers to the right of c.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2024/01/21/example11.png)\n    \n    \n    **Input:** edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3\n    **Output:** [2,0,0,0,0,0,2]\n    **Explanation:** Through server 0, there are 2 pairs of connectable servers: (4, 5) and (4, 6).\n    Through server 6, there are 2 pairs of connectable servers: (4, 5) and (0, 5).\n    It can be shown that no two servers are connectable through servers other than 0 and 6.\n    \n\n \n\n**Constraints:**\n\n  * `2 <= n <= 1000`\n  * `edges.length == n - 1`\n  * `edges[i].length == 3`\n  * `0 <= ai, bi < n`\n  * `edges[i] = [ai, bi, weighti]`\n  * `1 <= weighti <= 106`\n  * `1 <= signalSpeed <= 106`\n  * The input is generated such that `edges` represents a valid tree.",
  "question": "You are given an unrooted weighted tree with `n` vertices representing servers numbered from `0` to `n - 1`, an array `edges` where `edges[i] = [ai, bi, weighti]` represents a bidirectional edge between vertices `ai` and `bi` of weight `weighti`. You are also given an integer `signalSpeed`.\n\nTwo servers `a` and `b` are **connectable** through a server `c` if:\n\n  * `a < b`, `a != c` and `b != c`.\n  * The distance from `c` to `a` is divisible by `signalSpeed`.\n  * The distance from `c` to `b` is divisible by `signalSpeed`.\n  * The path from `c` to `b` and the path from `c` to `a` do not share any edges.\n\n\n\nReturn _an integer array_ `count` _of length_ `n` _where_ `count[i]` _is the**number** of server pairs that are **connectable** through_ _the server_ `i`.",
  "examples": "**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2024/01/21/example22.png)\n    \n    \n    **Input:** edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1\n    **Output:** [0,4,6,6,4,0]\n    **Explanation:** Since signalSpeed is 1, count[c] is equal to the number of pairs of paths that start at c and do not share any edges.\n    In the case of the given path graph, count[c] is equal to the number of servers to the left of c multiplied by the servers to the right of c.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2024/01/21/example11.png)\n    \n    \n    **Input:** edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3\n    **Output:** [2,0,0,0,0,0,2]\n    **Explanation:** Through server 0, there are 2 pairs of connectable servers: (4, 5) and (4, 6).\n    Through server 6, there are 2 pairs of connectable servers: (4, 5) and (0, 5).\n    It can be shown that no two servers are connectable through servers other than 0 and 6.",
  "constraints": "**Constraints:**\n\n  * `2 <= n <= 1000`\n  * `edges.length == n - 1`\n  * `edges[i].length == 3`\n  * `0 <= ai, bi < n`\n  * `edges[i] = [ai, bi, weighti]`\n  * `1 <= weighti <= 106`\n  * `1 <= signalSpeed <= 106`\n  * The input is generated such that `edges` represents a valid tree.",
  "topics": ["Array", "Tree", "Depth-First Search"],
  "total_accepted": 16189,
  "total_submissions": 29123,
  "acceptance_rate": "55.6%",
  "similar_questions": [
    {
      "title": "Minimum Height Trees",
      "slug": "minimum-height-trees",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/minimum-height-trees/"
    },
    {
      "title": "Sum of Distances in Tree",
      "slug": "sum-of-distances-in-tree",
      "difficulty": "Hard",
      "url": "https://leetcode.com/problems/sum-of-distances-in-tree/"
    }
  ],
  "hints": [
    "Take each node as the root of the tree, run DFS, and save for each node <code>i</code>, the number of nodes in the subtree rooted at <code>i</code> whose distance to the root is divisible by <code>signalSpeed</code>.",
    "If the root has <code>m</code> children named <code>c<sub>1</sub>, c<sub>2</sub>, …, c<sub>m</sub></code> that respectively have <code>num[c<sub>1</sub>], num[c<sub>2</sub>], …, num[c<sub>m</sub>]</code> nodes in their subtrees whose distance is divisible by signalSpeed. Then, there are <code>((S - num[c<sub>i</sub>]) * num[c<sub>i</sub>]) / 2</code>that are connectable through the root that we have fixed, where <code>S</code> is the sum of <code>num[c<sub>i</sub>]</code>."
  ]
}
