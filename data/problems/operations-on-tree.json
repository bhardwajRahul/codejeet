{
  "id": "1993",
  "title": "Operations on Tree",
  "slug": "operations-on-tree",
  "difficulty": "Medium",
  "category": "Algorithms",
  "content_html": "<p>You are given a tree with <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> in the form of a parent array <code>parent</code> where <code>parent[i]</code> is the parent of the <code>i<sup>th</sup></code> node. The root of the tree is node <code>0</code>, so <code>parent[0] = -1</code> since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree.</p>\n\n<p>The data structure should support the following functions:</p>\n\n<ul>\n\t<li><strong>Lock:</strong> <strong>Locks</strong> the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.</li>\n\t<li><strong>Unlock: Unlocks</strong> the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.</li>\n\t<li><b>Upgrade</b><strong>: Locks</strong> the given node for the given user and <strong>unlocks</strong> all of its descendants <strong>regardless</strong> of who locked it. You may only upgrade a node if <strong>all</strong> 3 conditions are true:\n\t<ul>\n\t\t<li>The node is unlocked,</li>\n\t\t<li>It has at least one locked descendant (by <strong>any</strong> user), and</li>\n\t\t<li>It does not have any locked ancestors.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Implement the <code>LockingTree</code> class:</p>\n\n<ul>\n\t<li><code>LockingTree(int[] parent)</code> initializes the data structure with the parent array.</li>\n\t<li><code>lock(int num, int user)</code> returns <code>true</code> if it is possible for the user with id <code>user</code> to lock the node <code>num</code>, or <code>false</code> otherwise. If it is possible, the node <code>num</code> will become<strong> locked</strong> by the user with id <code>user</code>.</li>\n\t<li><code>unlock(int num, int user)</code> returns <code>true</code> if it is possible for the user with id <code>user</code> to unlock the node <code>num</code>, or <code>false</code> otherwise. If it is possible, the node <code>num</code> will become <strong>unlocked</strong>.</li>\n\t<li><code>upgrade(int num, int user)</code> returns <code>true</code> if it is possible for the user with id <code>user</code> to upgrade the node <code>num</code>, or <code>false</code> otherwise. If it is possible, the node <code>num</code> will be <strong>upgraded</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/29/untitled.png\" style=\"width: 375px; height: 246px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;LockingTree&quot;, &quot;lock&quot;, &quot;unlock&quot;, &quot;unlock&quot;, &quot;lock&quot;, &quot;upgrade&quot;, &quot;lock&quot;]\n[[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]\n<strong>Output</strong>\n[null, true, false, true, true, true, false]\n\n<strong>Explanation</strong>\nLockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);\nlockingTree.lock(2, 2);    // return true because node 2 is unlocked.\n                           // Node 2 will now be locked by user 2.\nlockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.\nlockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.\n                           // Node 2 will now be unlocked.\nlockingTree.lock(4, 5);    // return true because node 4 is unlocked.\n                           // Node 4 will now be locked by user 5.\nlockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).\n                           // Node 0 will now be locked by user 1 and node 4 will now be unlocked.\nlockingTree.lock(0, 1);    // return false because node 0 is already locked.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == parent.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 2000</code></li>\n\t<li><code>0 &lt;= parent[i] &lt;= n - 1</code> for <code>i != 0</code></li>\n\t<li><code>parent[0] == -1</code></li>\n\t<li><code>0 &lt;= num &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= user &lt;= 10<sup>4</sup></code></li>\n\t<li><code>parent</code> represents a valid tree.</li>\n\t<li>At most <code>2000</code> calls <strong>in total</strong> will be made to <code>lock</code>, <code>unlock</code>, and <code>upgrade</code>.</li>\n</ul>\n",
  "content_markdown": "You are given a tree with `n` nodes numbered from `0` to `n - 1` in the form of a parent array `parent` where `parent[i]` is the parent of the `ith` node. The root of the tree is node `0`, so `parent[0] = -1` since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree.\n\nThe data structure should support the following functions:\n\n  * **Lock:** **Locks** the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.\n  * **Unlock: Unlocks** the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.\n  * **Upgrade****: Locks** the given node for the given user and **unlocks** all of its descendants **regardless** of who locked it. You may only upgrade a node if **all** 3 conditions are true: \n    * The node is unlocked,\n    * It has at least one locked descendant (by **any** user), and\n    * It does not have any locked ancestors.\n\n\n\nImplement the `LockingTree` class:\n\n  * `LockingTree(int[] parent)` initializes the data structure with the parent array.\n  * `lock(int num, int user)` returns `true` if it is possible for the user with id `user` to lock the node `num`, or `false` otherwise. If it is possible, the node `num` will become**locked** by the user with id `user`.\n  * `unlock(int num, int user)` returns `true` if it is possible for the user with id `user` to unlock the node `num`, or `false` otherwise. If it is possible, the node `num` will become **unlocked**.\n  * `upgrade(int num, int user)` returns `true` if it is possible for the user with id `user` to upgrade the node `num`, or `false` otherwise. If it is possible, the node `num` will be **upgraded**.\n\n\n\n \n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/07/29/untitled.png)\n    \n    \n    **Input**\n    [\"LockingTree\", \"lock\", \"unlock\", \"unlock\", \"lock\", \"upgrade\", \"lock\"]\n    [[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]\n    **Output**\n    [null, true, false, true, true, true, false]\n    \n    **Explanation**\n    LockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);\n    lockingTree.lock(2, 2);    // return true because node 2 is unlocked.\n                               // Node 2 will now be locked by user 2.\n    lockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.\n    lockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.\n                               // Node 2 will now be unlocked.\n    lockingTree.lock(4, 5);    // return true because node 4 is unlocked.\n                               // Node 4 will now be locked by user 5.\n    lockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).\n                               // Node 0 will now be locked by user 1 and node 4 will now be unlocked.\n    lockingTree.lock(0, 1);    // return false because node 0 is already locked.\n    \n\n \n\n**Constraints:**\n\n  * `n == parent.length`\n  * `2 <= n <= 2000`\n  * `0 <= parent[i] <= n - 1` for `i != 0`\n  * `parent[0] == -1`\n  * `0 <= num <= n - 1`\n  * `1 <= user <= 104`\n  * `parent` represents a valid tree.\n  * At most `2000` calls **in total** will be made to `lock`, `unlock`, and `upgrade`.",
  "question": "You are given a tree with `n` nodes numbered from `0` to `n - 1` in the form of a parent array `parent` where `parent[i]` is the parent of the `ith` node. The root of the tree is node `0`, so `parent[0] = -1` since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree.\n\nThe data structure should support the following functions:\n\n  * **Lock:** **Locks** the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.\n  * **Unlock: Unlocks** the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.\n  * **Upgrade****: Locks** the given node for the given user and **unlocks** all of its descendants **regardless** of who locked it. You may only upgrade a node if **all** 3 conditions are true: \n    * The node is unlocked,\n    * It has at least one locked descendant (by **any** user), and\n    * It does not have any locked ancestors.\n\n\n\nImplement the `LockingTree` class:\n\n  * `LockingTree(int[] parent)` initializes the data structure with the parent array.\n  * `lock(int num, int user)` returns `true` if it is possible for the user with id `user` to lock the node `num`, or `false` otherwise. If it is possible, the node `num` will become**locked** by the user with id `user`.\n  * `unlock(int num, int user)` returns `true` if it is possible for the user with id `user` to unlock the node `num`, or `false` otherwise. If it is possible, the node `num` will become **unlocked**.\n  * `upgrade(int num, int user)` returns `true` if it is possible for the user with id `user` to upgrade the node `num`, or `false` otherwise. If it is possible, the node `num` will be **upgraded**.",
  "examples": "**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/07/29/untitled.png)\n    \n    \n    **Input**\n    [\"LockingTree\", \"lock\", \"unlock\", \"unlock\", \"lock\", \"upgrade\", \"lock\"]\n    [[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]\n    **Output**\n    [null, true, false, true, true, true, false]\n    \n    **Explanation**\n    LockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);\n    lockingTree.lock(2, 2);    // return true because node 2 is unlocked.\n                               // Node 2 will now be locked by user 2.\n    lockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.\n    lockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.\n                               // Node 2 will now be unlocked.\n    lockingTree.lock(4, 5);    // return true because node 4 is unlocked.\n                               // Node 4 will now be locked by user 5.\n    lockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).\n                               // Node 0 will now be locked by user 1 and node 4 will now be unlocked.\n    lockingTree.lock(0, 1);    // return false because node 0 is already locked.",
  "constraints": "**Constraints:**\n\n  * `n == parent.length`\n  * `2 <= n <= 2000`\n  * `0 <= parent[i] <= n - 1` for `i != 0`\n  * `parent[0] == -1`\n  * `0 <= num <= n - 1`\n  * `1 <= user <= 104`\n  * `parent` represents a valid tree.\n  * At most `2000` calls **in total** will be made to `lock`, `unlock`, and `upgrade`.",
  "topics": ["Array", "Hash Table", "Tree", "Depth-First Search", "Breadth-First Search", "Design"],
  "total_accepted": 24312,
  "total_submissions": 53975,
  "acceptance_rate": "45.0%",
  "similar_questions": [
    {
      "title": "Throne Inheritance",
      "slug": "throne-inheritance",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/throne-inheritance/"
    }
  ],
  "hints": [
    "How can we use the small constraints to help us solve the problem?",
    "How can we traverse the ancestors and descendants of a node?"
  ]
}
