{
  "id": "2630",
  "title": "Memoize II",
  "slug": "memoize-ii",
  "difficulty": "Hard",
  "category": "JavaScript",
  "content_html": "<p>Given a function <code>fn</code>,&nbsp;return&nbsp;a&nbsp;<strong>memoized</strong>&nbsp;version of that function.</p>\n\n<p>A&nbsp;<strong>memoized&nbsp;</strong>function is a function that will never be called twice with&nbsp;the same inputs. Instead it will return&nbsp;a cached value.</p>\n\n<p><code>fn</code>&nbsp;can be any function and there are no constraints on what type of values it accepts. Inputs are considered identical if they are&nbsp;<code>===</code> to each other.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \ngetInputs = () =&gt; [[2,2],[2,2],[1,2]]\nfn = function (a, b) { return a + b; }\n<strong>Output:</strong> [{&quot;val&quot;:4,&quot;calls&quot;:1},{&quot;val&quot;:4,&quot;calls&quot;:1},{&quot;val&quot;:3,&quot;calls&quot;:2}]\n<strong>Explanation:</strong>\nconst inputs = getInputs();\nconst memoized = memoize(fn);\nfor (const arr of inputs) {\n  memoized(...arr);\n}\n\nFor the inputs of (2, 2): 2 + 2 = 4, and it required a call to fn().\nFor the inputs of (2, 2): 2 + 2 = 4, but those inputs were seen before so no call to fn() was required.\nFor the inputs of (1, 2): 1 + 2 = 3, and it required another call to fn() for a total of 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> \ngetInputs = () =&gt; [[{},{}],[{},{}],[{},{}]] \nfn = function (a, b) { return ({...a, ...b}); }\n<strong>Output:</strong> [{&quot;val&quot;:{},&quot;calls&quot;:1},{&quot;val&quot;:{},&quot;calls&quot;:2},{&quot;val&quot;:{},&quot;calls&quot;:3}]\n<strong>Explanation:</strong>\nMerging two empty objects will always result in an empty object. It may seem like there should only be 1&nbsp;call to fn() because of cache-hits, however none of those objects are === to each other.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> \ngetInputs = () =&gt; { const o = {}; return [[o,o],[o,o],[o,o]]; }\nfn = function (a, b) { return ({...a, ...b}); }\n<strong>Output:</strong> [{&quot;val&quot;:{},&quot;calls&quot;:1},{&quot;val&quot;:{},&quot;calls&quot;:1},{&quot;val&quot;:{},&quot;calls&quot;:1}]\n<strong>Explanation:</strong>\nMerging two empty objects will always result in an empty object. The 2nd and 3rd third function calls result in a cache-hit. This is because every object passed in is identical.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= inputs.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= inputs.flat().length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>inputs[i][j] != NaN</code></li>\n</ul>\n",
  "content_markdown": "Given a function `fn`, return a **memoized**  version of that function.\n\nA **memoized  **function is a function that will never be called twice with the same inputs. Instead it will return a cached value.\n\n`fn` can be any function and there are no constraints on what type of values it accepts. Inputs are considered identical if they are `===` to each other.\n\n \n\n**Example 1:**\n    \n    \n    **Input:** \n    getInputs = () => [[2,2],[2,2],[1,2]]\n    fn = function (a, b) { return a + b; }\n    **Output:** [{\"val\":4,\"calls\":1},{\"val\":4,\"calls\":1},{\"val\":3,\"calls\":2}]\n    **Explanation:**\n    const inputs = getInputs();\n    const memoized = memoize(fn);\n    for (const arr of inputs) {\n      memoized(...arr);\n    }\n    \n    For the inputs of (2, 2): 2 + 2 = 4, and it required a call to fn().\n    For the inputs of (2, 2): 2 + 2 = 4, but those inputs were seen before so no call to fn() was required.\n    For the inputs of (1, 2): 1 + 2 = 3, and it required another call to fn() for a total of 2.\n    \n\n**Example 2:**\n    \n    \n    **Input:** \n    getInputs = () => [[{},{}],[{},{}],[{},{}]] \n    fn = function (a, b) { return ({...a, ...b}); }\n    **Output:** [{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":2},{\"val\":{},\"calls\":3}]\n    **Explanation:**\n    Merging two empty objects will always result in an empty object. It may seem like there should only be 1 call to fn() because of cache-hits, however none of those objects are === to each other.\n    \n\n**Example 3:**\n    \n    \n    **Input:** \n    getInputs = () => { const o = {}; return [[o,o],[o,o],[o,o]]; }\n    fn = function (a, b) { return ({...a, ...b}); }\n    **Output:** [{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1}]\n    **Explanation:**\n    Merging two empty objects will always result in an empty object. The 2nd and 3rd third function calls result in a cache-hit. This is because every object passed in is identical.\n    \n\n \n\n**Constraints:**\n\n  * `1 <= inputs.length <= 105`\n  * `0 <= inputs.flat().length <= 105`\n  * `inputs[i][j] != NaN`",
  "question": "Given a function `fn`, return a **memoized**  version of that function.\n\nA **memoized  **function is a function that will never be called twice with the same inputs. Instead it will return a cached value.\n\n`fn` can be any function and there are no constraints on what type of values it accepts. Inputs are considered identical if they are `===` to each other.",
  "examples": "**Example 1:**\n    \n    \n    **Input:** \n    getInputs = () => [[2,2],[2,2],[1,2]]\n    fn = function (a, b) { return a + b; }\n    **Output:** [{\"val\":4,\"calls\":1},{\"val\":4,\"calls\":1},{\"val\":3,\"calls\":2}]\n    **Explanation:**\n    const inputs = getInputs();\n    const memoized = memoize(fn);\n    for (const arr of inputs) {\n      memoized(...arr);\n    }\n    \n    For the inputs of (2, 2): 2 + 2 = 4, and it required a call to fn().\n    For the inputs of (2, 2): 2 + 2 = 4, but those inputs were seen before so no call to fn() was required.\n    For the inputs of (1, 2): 1 + 2 = 3, and it required another call to fn() for a total of 2.\n    \n\n**Example 2:**\n    \n    \n    **Input:** \n    getInputs = () => [[{},{}],[{},{}],[{},{}]] \n    fn = function (a, b) { return ({...a, ...b}); }\n    **Output:** [{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":2},{\"val\":{},\"calls\":3}]\n    **Explanation:**\n    Merging two empty objects will always result in an empty object. It may seem like there should only be 1 call to fn() because of cache-hits, however none of those objects are === to each other.\n    \n\n**Example 3:**\n    \n    \n    **Input:** \n    getInputs = () => { const o = {}; return [[o,o],[o,o],[o,o]]; }\n    fn = function (a, b) { return ({...a, ...b}); }\n    **Output:** [{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1}]\n    **Explanation:**\n    Merging two empty objects will always result in an empty object. The 2nd and 3rd third function calls result in a cache-hit. This is because every object passed in is identical.",
  "constraints": "**Constraints:**\n\n  * `1 <= inputs.length <= 105`\n  * `0 <= inputs.flat().length <= 105`\n  * `inputs[i][j] != NaN`",
  "topics": [],
  "total_accepted": 11383,
  "total_submissions": 29663,
  "acceptance_rate": "38.4%",
  "similar_questions": [
    {
      "title": "Memoize",
      "slug": "memoize",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/memoize/"
    },
    {
      "title": "Curry",
      "slug": "curry",
      "difficulty": "Medium",
      "url": "https://leetcode.com/problems/curry/"
    }
  ],
  "hints": [
    "Just because JSON.stringify(obj1) === JSON.stringify(obj2), doesn't necessarily mean obj1 === obj2.",
    "You could iterate over all previously passed inputs to check if there has been a match. However, that will be very slow.",
    "Javascript Maps are a could way to associate arbitrary data.",
    "Make a tree structure of Maps. The depth of the tree should match the number of input parameters."
  ]
}
