{
  "id": "2546",
  "title": "Apply Bitwise Operations to Make Strings Equal",
  "slug": "apply-bitwise-operations-to-make-strings-equal",
  "difficulty": "Medium",
  "category": "Algorithms",
  "content_html": "<p>You are given two <strong>0-indexed binary</strong> strings <code>s</code> and <code>target</code> of the same length <code>n</code>. You can do the following operation on <code>s</code> <strong>any</strong> number of times:</p>\n\n<ul>\n\t<li>Choose two <strong>different</strong> indices <code>i</code> and <code>j</code> where <code>0 &lt;= i, j &lt; n</code>.</li>\n\t<li>Simultaneously, replace <code>s[i]</code> with (<code>s[i]</code> <strong>OR</strong> <code>s[j]</code>) and <code>s[j]</code> with (<code>s[i]</code> <strong>XOR</strong> <code>s[j]</code>).</li>\n</ul>\n\n<p>For example, if <code>s = &quot;0110&quot;</code>, you can choose <code>i = 0</code> and <code>j = 2</code>, then simultaneously replace <code>s[0]</code> with (<code>s[0]</code> <strong>OR</strong> <code>s[2]</code> = <code>0</code> <strong>OR</strong> <code>1</code> = <code>1</code>), and <code>s[2]</code> with (<code>s[0]</code> <strong>XOR</strong> <code>s[2]</code> = <code>0</code> <strong>XOR</strong> <code>1</code> = <code>1</code>), so we will have <code>s = &quot;1110&quot;</code>.</p>\n\n<p>Return <code>true</code> <em>if you can make the string </em><code>s</code><em> equal to </em><code>target</code><em>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1010&quot;, target = &quot;0110&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We can do the following operations:\n- Choose i = 2 and j = 0. We have now s = &quot;<strong><u>0</u></strong>0<strong><u>1</u></strong>0&quot;.\n- Choose i = 2 and j = 1. We have now s = &quot;0<strong><u>11</u></strong>0&quot;.\nSince we can make s equal to target, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;11&quot;, target = &quot;00&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> It is not possible to make s equal to target with any number of operations.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == s.length == target.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> and <code>target</code> consist of only the digits <code>0</code> and <code>1</code>.</li>\n</ul>\n",
  "content_markdown": "You are given two **0-indexed binary** strings `s` and `target` of the same length `n`. You can do the following operation on `s` **any** number of times:\n\n  * Choose two **different** indices `i` and `j` where `0 <= i, j < n`.\n  * Simultaneously, replace `s[i]` with (`s[i]` **OR** `s[j]`) and `s[j]` with (`s[i]` **XOR** `s[j]`).\n\n\n\nFor example, if `s = \"0110\"`, you can choose `i = 0` and `j = 2`, then simultaneously replace `s[0]` with (`s[0]` **OR** `s[2]` = `0` **OR** `1` = `1`), and `s[2]` with (`s[0]` **XOR** `s[2]` = `0` **XOR** `1` = `1`), so we will have `s = \"1110\"`.\n\nReturn `true` _if you can make the string_`s` _equal to_`target` _, or_`false` _otherwise_.\n\n \n\n**Example 1:**\n    \n    \n    **Input:** s = \"1010\", target = \"0110\"\n    **Output:** true\n    **Explanation:** We can do the following operations:\n    - Choose i = 2 and j = 0. We have now s = \"**_0_** 0** _1_** 0\".\n    - Choose i = 2 and j = 1. We have now s = \"0** _11_** 0\".\n    Since we can make s equal to target, we return true.\n    \n\n**Example 2:**\n    \n    \n    **Input:** s = \"11\", target = \"00\"\n    **Output:** false\n    **Explanation:** It is not possible to make s equal to target with any number of operations.\n    \n\n \n\n**Constraints:**\n\n  * `n == s.length == target.length`\n  * `2 <= n <= 105`\n  * `s` and `target` consist of only the digits `0` and `1`.",
  "question": "You are given two **0-indexed binary** strings `s` and `target` of the same length `n`. You can do the following operation on `s` **any** number of times:\n\n  * Choose two **different** indices `i` and `j` where `0 <= i, j < n`.\n  * Simultaneously, replace `s[i]` with (`s[i]` **OR** `s[j]`) and `s[j]` with (`s[i]` **XOR** `s[j]`).\n\n\n\nFor example, if `s = \"0110\"`, you can choose `i = 0` and `j = 2`, then simultaneously replace `s[0]` with (`s[0]` **OR** `s[2]` = `0` **OR** `1` = `1`), and `s[2]` with (`s[0]` **XOR** `s[2]` = `0` **XOR** `1` = `1`), so we will have `s = \"1110\"`.\n\nReturn `true` _if you can make the string_`s` _equal to_`target` _, or_`false` _otherwise_.",
  "examples": "**Example 1:**\n    \n    \n    **Input:** s = \"1010\", target = \"0110\"\n    **Output:** true\n    **Explanation:** We can do the following operations:\n    - Choose i = 2 and j = 0. We have now s = \"**_0_** 0** _1_** 0\".\n    - Choose i = 2 and j = 1. We have now s = \"0** _11_** 0\".\n    Since we can make s equal to target, we return true.\n    \n\n**Example 2:**\n    \n    \n    **Input:** s = \"11\", target = \"00\"\n    **Output:** false\n    **Explanation:** It is not possible to make s equal to target with any number of operations.",
  "constraints": "**Constraints:**\n\n  * `n == s.length == target.length`\n  * `2 <= n <= 105`\n  * `s` and `target` consist of only the digits `0` and `1`.",
  "topics": ["String", "Bit Manipulation"],
  "total_accepted": 22616,
  "total_submissions": 53143,
  "acceptance_rate": "42.6%",
  "similar_questions": [
    {
      "title": "Minimum One Bit Operations to Make Integers Zero",
      "slug": "minimum-one-bit-operations-to-make-integers-zero",
      "difficulty": "Hard",
      "url": "https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/"
    }
  ],
  "hints": [
    "Think of when it is impossible to convert the string to the target.",
    "If exactly one of the strings is having all 0’s, then it is impossible. And it is possible in all other cases. Why is that true?"
  ]
}
